<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>操作系统_总结 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="以下是参加清华大学2025 春夏季开源操作系统训练营学习blog。本节关于操作系统的文件系统相关的内容。 运行内核123456789KERNEL_ENTRY_PA :&#x3D; 0x80200000@qemu-system-riscv64 \    -M 128m \    -machine virt \    -nographic \    -bios $(BOOTLOADER) \    -devic">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统_总结">
<meta property="og:url" content="https://rubick-hqm.github.io/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="以下是参加清华大学2025 春夏季开源操作系统训练营学习blog。本节关于操作系统的文件系统相关的内容。 运行内核123456789KERNEL_ENTRY_PA :&#x3D; 0x80200000@qemu-system-riscv64 \    -M 128m \    -machine virt \    -nographic \    -bios $(BOOTLOADER) \    -devic">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://rubick-hqm.github.io/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/kernel_layout.drawio.svg">
<meta property="og:image" content="https://rubick-hqm.github.io/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/sv39-va-pa.png">
<meta property="og:image" content="https://rubick-hqm.github.io/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/kernel-as-high.png">
<meta property="og:image" content="https://rubick-hqm.github.io/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/kernel-as-low.png">
<meta property="og:image" content="https://rubick-hqm.github.io/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/satp.png">
<meta property="og:image" content="https://rubick-hqm.github.io/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/app-as-full.png">
<meta property="og:image" content="https://rubick-hqm.github.io/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/user-stack-cmdargs.png">
<meta property="og:image" content="https://rubick-hqm.github.io/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/app-as-full.png">
<meta property="og:image" content="https://rubick-hqm.github.io/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/kernel-as-high.png">
<meta property="article:published_time" content="2025-04-24T07:46:21.874Z">
<meta property="article:modified_time" content="2025-04-25T11:39:40.356Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rubick-hqm.github.io/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/kernel_layout.drawio.svg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://rubick-hqm.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-操作系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2025-04-24T07:46:21.874Z" itemprop="datePublished">2025-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      操作系统_总结
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>以下是参加清华大学2025 春夏季开源操作系统训练营学习blog。<br>本节关于操作系统的文件系统相关的内容。</p>
<h2 id="运行内核"><a href="#运行内核" class="headerlink" title="运行内核"></a>运行内核</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">KERNEL_ENTRY_PA := 0x80200000</span><br><span class="line">@qemu-system-riscv64 \</span><br><span class="line">    -M 128m \</span><br><span class="line">    -machine virt \</span><br><span class="line">    -nographic \</span><br><span class="line">    -bios $(BOOTLOADER) \</span><br><span class="line">    -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) \</span><br><span class="line">    -drive file=$(FS_IMG),if=none,format=raw,id=x0 \</span><br><span class="line">    -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br></pre></td></tr></table></figure>
<p>根据启动命令，通过bios引导加载内核到物理地址是0x80200000。<br>根据连接脚本可知内核的分布如下图所示：<br><img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/kernel_layout.drawio.svg" alt="内核布局图"></p>
<p>从入口_start开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    .section .text.entry</span><br><span class="line">    .globl _start</span><br><span class="line">_start:</span><br><span class="line">    la sp, boot_stack_top</span><br><span class="line">    call rust_main</span><br><span class="line"></span><br><span class="line">    .section .bss.stack</span><br><span class="line">    .globl boot_stack_lower_bound</span><br><span class="line">boot_stack_lower_bound:</span><br><span class="line">    .space 4096 * 16</span><br><span class="line">    .globl boot_stack_top</span><br><span class="line">boot_stack_top:</span><br></pre></td></tr></table></figure>
<p>我们看到将sp设置到了栈顶位置，栈的大小为16KB。之后就到了rust世界rust_main</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;[kernel] Hello, world!&quot;</span>);</span><br><span class="line">    logging::<span class="title function_ invoke__">init</span>();</span><br><span class="line">    mm::<span class="title function_ invoke__">init</span>();</span><br><span class="line">    mm::<span class="title function_ invoke__">remap_test</span>();</span><br><span class="line">    trap::<span class="title function_ invoke__">init</span>();</span><br><span class="line">    trap::<span class="title function_ invoke__">enable_timer_interrupt</span>();</span><br><span class="line">    timer::<span class="title function_ invoke__">set_next_trigger</span>();</span><br><span class="line">    fs::<span class="title function_ invoke__">list_apps</span>();</span><br><span class="line">    task::<span class="title function_ invoke__">add_initproc</span>();</span><br><span class="line">    task::<span class="title function_ invoke__">run_tasks</span>();</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Unreachable in rust_main!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>rust_main中先调用了clear_bss函数，清空.bss段数据，然后初始化日志系统，接着就到了内存管理部分。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>() &#123;</span><br><span class="line">    heap_allocator::<span class="title function_ invoke__">init_heap</span>();</span><br><span class="line">    frame_allocator::<span class="title function_ invoke__">init_frame_allocator</span>();</span><br><span class="line">    KERNEL_SPACE.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">activate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先是两个分配器初始化，一个是堆分配器，一个是物理页分配器。</p>
<h3 id="堆分配器"><a href="#堆分配器" class="headerlink" title="堆分配器"></a>堆分配器</h3><p>为了能在内核中使用Vec等容器，就引入了堆分配器。堆分配器使用的内存在内核的.data段中，大小为32MB</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> HEAP_SPACE: [<span class="type">u8</span>; KERNEL_HEAP_SIZE] = [<span class="number">0</span>; KERNEL_HEAP_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init_heap</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        HEAP_ALLOCATOR</span><br><span class="line">            .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">init</span>(HEAP_SPACE.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, KERNEL_HEAP_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="物理页分配器"><a href="#物理页分配器" class="headerlink" title="物理页分配器"></a>物理页分配器</h3><p>启动qemu时，我们使用了<code>-M 128M</code>，能够支配的物理内存为128M，但是要除去内核大小<br>所以我们能支配的可用物理内存地址为ekernel开始到0x88000000结束。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init_frame_allocator</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ekernel</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    FRAME_ALLOCATOR.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">init</span>(</span><br><span class="line">        PhysAddr::<span class="title function_ invoke__">from</span>(ekernel <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">ceil</span>(),</span><br><span class="line">        PhysAddr::<span class="title function_ invoke__">from</span>(MEMORY_END).<span class="title function_ invoke__">floor</span>(),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    current: <span class="type">usize</span>,</span><br><span class="line">    end: <span class="type">usize</span>,</span><br><span class="line">    recycled: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">alloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PhysPageNum&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">dealloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, ppn: PhysPageNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过StackFrameAllocator来管理物理页，管理的物理页为[current, end)。<br>当申请新物理页时，先从recycled中获取，如果recycled为空，则current+1，使用新的物理页。<br>回收时，将其加入recycled中。<br>我们引入RAII机制，使用FrameTracker来表示一个物理页，当FrameTracker离开作用域时，会自动回收物理页。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="comment">/// physical page number</span></span><br><span class="line">    <span class="keyword">pub</span> ppn: PhysPageNum,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="comment">/// Create a new FrameTracker</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(ppn: PhysPageNum) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// page cleaning</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">bytes_array</span> = ppn.<span class="title function_ invoke__">get_bytes_array</span>();</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> bytes_array &#123;</span><br><span class="line">            *i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ppn &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">frame_dealloc</span>(<span class="keyword">self</span>.ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个物理页分配器提供两个API供外部调用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">frame_alloc</span>() <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;FrameTracker&gt; &#123;</span><br><span class="line">    FRAME_ALLOCATOR</span><br><span class="line">        .<span class="title function_ invoke__">exclusive_access</span>()</span><br><span class="line">        .<span class="title function_ invoke__">alloc</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(FrameTracker::new)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Deallocate a physical page frame with a given ppn</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">frame_dealloc</span>(ppn: PhysPageNum) &#123;</span><br><span class="line">    FRAME_ALLOCATOR.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">dealloc</span>(ppn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内核地址空间"><a href="#内核地址空间" class="headerlink" title="内核地址空间"></a>内核地址空间</h3><p>有了堆分配器，以及物理页分配器之后，我们就能愉快的引入虚拟内存概念，以及创建内核地址空间了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="comment">/// The kernel&#x27;s initial memory mapping(kernel address space)</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> KERNEL_SPACE: Arc&lt;UPSafeCell&lt;MemorySet&gt;&gt; =</span><br><span class="line">        Arc::<span class="title function_ invoke__">new</span>(<span class="keyword">unsafe</span> &#123; UPSafeCell::<span class="title function_ invoke__">new</span>(MemorySet::<span class="title function_ invoke__">new_kernel</span>()) &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>KERNEL_SPACE是一个指针存放在.bss，实际的内核地址空间数据结构MemorySet存放在堆空间.data中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    <span class="comment">/// page table</span></span><br><span class="line">    <span class="keyword">pub</span> page_table: PageTable,</span><br><span class="line">    <span class="comment">/// areas</span></span><br><span class="line">    <span class="keyword">pub</span> areas: <span class="type">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一共2个字段，page_table页表， areas逻辑段。<br>页表用来进行虚拟地址与物理地址的映射，逻辑段即数据内容比如内核的.text,.data段等。<br>内核地址空间包括的物理页即page_table中的物理页和areas中的物理页。</p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>这里使用SV39多级页表</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    root_ppn: PhysPageNum,</span><br><span class="line">    frames: <span class="type">Vec</span>&lt;FrameTracker&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>root_ppn是二级页表，frames是物理页的集合。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    PageTable &#123;</span><br><span class="line">        root_ppn: frame.ppn,</span><br><span class="line">        frames: <span class="built_in">vec!</span>[frame],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页表创建时，首先分配一个物理页作为一级页表，由frames管理，</p>
<p>API如下：</p>
<ul>
<li>map&#x2F;unmap基础功能是虚拟页与物理页的映射  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_pte_create</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">for</span> (i, idx) <span class="keyword">in</span> idxs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[*idx];</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">            result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(frame.ppn, PTEFlags::V);</span><br><span class="line">            <span class="keyword">self</span>.frames.<span class="title function_ invoke__">push</span>(frame);</span><br><span class="line">        &#125;</span><br><span class="line">        ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte_create</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(!pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is mapped before mapping&quot;</span>, vpn);</span><br><span class="line">    *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(ppn, flags | PTEFlags::V);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is invalid before unmapping&quot;</span>, vpn);</span><br><span class="line">    *pte = PageTableEntry::<span class="title function_ invoke__">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  map即API，先通过find_pte_create找到vpn对应页表项，将ppn映射到该页表项。并将标记设置位valid<br>  find_ptr_create逻辑如下：<br>  先根据虚拟页号得到页表的索引，虚拟页号一共27位，均分成3段，每段9位，所以页表包含512个页表项<br>  |25位未用|9位vpn[2]|9位vpn[1]|9位vpn[0]|12位页内偏移|<br>  先通过root_ppn的L2索引找到一级页表，再根据二级索引找到二级页表，再根据三级索引找到对应页表项<br>  刚开始只有L2页表即根页表，先根据L2索引vpn[2]在根页表的物理页中找到页表项，<br>  如果不存在页表项，就创建下一级页表，并将页表项指向该页表，然后逐级创建页表，填写页表项，<br>  到vpn[0]得到最终的物理页的页表项。</li>
<li>translate_va翻译虚拟地址为物理地址<br>  <img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/sv39-va-pa.png" alt="虚拟地址和物理地址转换">  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">translate_va</span>(&amp;<span class="keyword">self</span>, va: VirtAddr) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PhysAddr&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte</span>(va.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">floor</span>()).<span class="title function_ invoke__">map</span>(|pte| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">aligned_pa</span>: PhysAddr = pte.<span class="title function_ invoke__">ppn</span>().<span class="title function_ invoke__">into</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">offset</span> = va.<span class="title function_ invoke__">page_offset</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">aligned_pa_usize</span>: <span class="type">usize</span> = aligned_pa.<span class="title function_ invoke__">into</span>();</span><br><span class="line">        (aligned_pa_usize + offset).<span class="title function_ invoke__">into</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  先找到va的页表项，将页表项中的物理页地址加上页内偏移得到物理地址。</li>
</ul>
<h4 id="逻辑段"><a href="#逻辑段" class="headerlink" title="逻辑段"></a>逻辑段</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MapArea</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> vpn_range: VPNRange,</span><br><span class="line">    <span class="keyword">pub</span> data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;,</span><br><span class="line">    <span class="keyword">pub</span> map_type: MapType,</span><br><span class="line">    <span class="keyword">pub</span> map_perm: MapPermission,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MapArea用来描述逻辑段，包括页表项范围，页帧集合，页类型，页权限。</p>
<p>API如下：</p>
<ul>
<li>new，创建  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(</span><br><span class="line">    start_va: VirtAddr,</span><br><span class="line">    end_va: VirtAddr,</span><br><span class="line">    map_type: MapType,</span><br><span class="line">    map_perm: MapPermission,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">start_vpn</span>: VirtPageNum = start_va.<span class="title function_ invoke__">floor</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">end_vpn</span>: VirtPageNum = end_va.<span class="title function_ invoke__">ceil</span>();</span><br><span class="line">    <span class="keyword">Self</span> &#123;</span><br><span class="line">        vpn_range: VPNRange::<span class="title function_ invoke__">new</span>(start_vpn, end_vpn),</span><br><span class="line">        data_frames: BTreeMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        map_type,</span><br><span class="line">        map_perm,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  给定一段虚拟地址[start_va,end_va)，以map_type映射方式包括恒等映射以及分配物理帧两种映射方式<br>  再包括这一段逻辑的权限包括读，写，执行，以及是否用户可访问。</li>
<li>map&#x2F;unmap，映射  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ppn</span>: PhysPageNum;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.map_type &#123;</span><br><span class="line">        MapType::Identical =&gt; &#123;</span><br><span class="line">            ppn = <span class="title function_ invoke__">PhysPageNum</span>(vpn.<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MapType::Framed =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            ppn = frame.ppn;</span><br><span class="line">            <span class="keyword">self</span>.data_frames.<span class="title function_ invoke__">insert</span>(vpn, frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pte_flags</span> = PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.map_perm.bits).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    page_table.<span class="title function_ invoke__">map</span>(vpn, ppn, pte_flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">vpn</span> <span class="keyword">in</span> <span class="keyword">self</span>.vpn_range &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">map_one</span>(page_table, vpn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  将这段虚拟页以map_type的方式射映射到物理页中。<br>  恒等映射：即物理地址&#x3D;虚拟地址<br>  分配物理帧：通过frame_alloc分配一页物理页，通过page_table.map写到页表中。</li>
</ul>
<h4 id="创建内核地址空间"><a href="#创建内核地址空间" class="headerlink" title="创建内核地址空间"></a>创建内核地址空间</h4><p>回过头来看以下内核的地址空间初始化MemorySet::new_kernel()</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_kernel</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">memory_set</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new_bare</span>();</span><br><span class="line">    <span class="comment">// map trampoline</span></span><br><span class="line">    memory_set.<span class="title function_ invoke__">map_trampoline</span>();</span><br><span class="line">    <span class="comment">// map kernel sections</span></span><br><span class="line">    info!(<span class="string">&quot;.text [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, stext <span class="keyword">as</span> <span class="type">usize</span>, etext <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    info!(<span class="string">&quot;.rodata [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, srodata <span class="keyword">as</span> <span class="type">usize</span>, erodata <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    info!(<span class="string">&quot;.data [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, sdata <span class="keyword">as</span> <span class="type">usize</span>, edata <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    info!(</span><br><span class="line">        <span class="string">&quot;.bss [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,</span><br><span class="line">        sbss_with_stack <span class="keyword">as</span> <span class="type">usize</span>, ebss <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping .text section&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (stext <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (etext <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::X,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping .rodata section&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (srodata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (erodata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping .data section&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (sdata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (edata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::W,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping .bss section&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (sbss_with_stack <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (ebss <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::W,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping physical memory&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (ekernel <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MEMORY_END.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::W,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping memory-mapped registers&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">pair</span> <span class="keyword">in</span> MMIO &#123;</span><br><span class="line">        memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">            MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                (*pair).<span class="number">0</span>.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                ((*pair).<span class="number">0</span> + (*pair).<span class="number">1</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                MapType::Identical,</span><br><span class="line">                MapPermission::R | MapPermission::W,</span><br><span class="line">            ),</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    memory_set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/kernel-as-high.png" alt="高256G内核地址空间">]<br>首先将内核strampoline段映射到内核地址空间最高的一页中</p>
<p><img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/kernel-as-low.png" alt="低256G内核地址空间">]</p>
<ul>
<li>内核的.text .rodata .data .bss .kernel段恒等映射到内核地址空间中，</li>
<li>剩下物理内存[ekernel,MEMORY_END)恒等映射到内核地址空间中。</li>
<li>MMIO段也映射到内核地址空间中，用来使用块设备</li>
</ul>
<h4 id="启用MMU"><a href="#启用MMU" class="headerlink" title="启用MMU"></a>启用MMU</h4><p>至此我们就完成了内核地址空间的初始化。此后就可以启用MMU来使用虚拟地址了。<br><img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/satp.png" alt="启用MMU"><br>上图是 RV64 架构下 satp 的字段分布。当 MODE 设置为 0 的时候，所有访存都被视为物理地址；而设置为 8 时，SV39 分页机制被启用，所有 S&#x2F;U 特权级的访存被视为一个 39 位的虚拟地址，MMU 会将其转换成 56 位的物理地址；如果转换失败，则会触发异常。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">activate</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">satp</span> = <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">token</span>();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        satp::<span class="title function_ invoke__">write</span>(satp);</span><br><span class="line">        asm!(<span class="string">&quot;sfence.vma&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">token</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="number">8usize</span> &lt;&lt; <span class="number">60</span> | <span class="keyword">self</span>.root_ppn.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>activate函数将内核地址空间的root_ppn作为satp的根节点，并设置satp的MODE为8，即SV39分页机制。mmu就会去查找root_ppn物理页下的页表，然后根据虚拟地址转换成物理地址。</p>
<h2 id="内核中的中断处理"><a href="#内核中的中断处理" class="headerlink" title="内核中的中断处理"></a>内核中的中断处理</h2><p>上面我们启用MMU之后，设置一下内核中的中断处理，以防比如访问了非法地址导致内核没有相应错误输出</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">set_kernel_trap_entry</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">set_kernel_trap_entry</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">__trap_from_kernel</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        stvec::<span class="title function_ invoke__">write</span>(__trap_from_kernel <span class="keyword">as</span> <span class="type">usize</span>, TrapMode::Direct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap_from_kernel</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">use</span> riscv::register::sepc;</span><br><span class="line">    trace!(<span class="string">&quot;stval = &#123;:#x&#125;, sepc = &#123;:#x&#125;&quot;</span>, stval::<span class="title function_ invoke__">read</span>(), sepc::<span class="title function_ invoke__">read</span>());</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;a trap &#123;:?&#125; from kernel!&quot;</span>, scause::<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">cause</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    .section .data</span><br><span class="line">    # emergency stack for kernel trap</span><br><span class="line">    # in order to print trap info even if the kernel stack is corrupted.</span><br><span class="line">__emergency:</span><br><span class="line">    .align 4</span><br><span class="line">    .space 1024 * 4</span><br><span class="line">__emergency_end:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    .section .text</span><br><span class="line">    .globl __trap_from_kernel</span><br><span class="line">    # 2^2=4 bytes aligned for stvec</span><br><span class="line">    .align 2</span><br><span class="line">__trap_from_kernel:</span><br><span class="line">    la sp, __emergency_end</span><br><span class="line">    j trap_from_kernel    </span><br></pre></td></tr></table></figure>
<p>比较简单，先将stvec指向__trap_from_kernel，在.data中分配4k大小的emergency栈，然后将栈指向emergency，跳转到trap_from_kernel，输出错误信息。</p>
<h2 id="启用时钟中断"><a href="#启用时钟中断" class="headerlink" title="启用时钟中断"></a>启用时钟中断</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">enable_timer_interrupt</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        sie::<span class="title function_ invoke__">set_stimer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_next_trigger</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">set_timer</span>(<span class="title function_ invoke__">get_time</span>() + CLOCK_FREQ / TICKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_timer</span>(timer: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">sbi_call</span>(SBI_SET_TIMER, timer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启用时钟中断，设置下一次触发时间，设置定时器。</p>
<h2 id="加载文件系统"><a href="#加载文件系统" class="headerlink" title="加载文件系统"></a>加载文件系统</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="comment">/// 根节点</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> ROOT_INODE: Arc&lt;Inode&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">efs</span> = EasyFileSystem::<span class="title function_ invoke__">open</span>(BLOCK_DEVICE.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">        Arc::<span class="title function_ invoke__">new</span>(EasyFileSystem::<span class="title function_ invoke__">root_inode</span>(&amp;efs))</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内核堆空间创建了文件系统EasyFileSystem，并获取了根目录的inode。</p>
<h2 id="启动Init进程"><a href="#启动Init进程" class="headerlink" title="启动Init进程"></a>启动Init进程</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="comment">/// Creation of initial process</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// the name &quot;initproc&quot; may be changed to any other app name like &quot;usertests&quot;,</span></span><br><span class="line">    <span class="comment">/// but we have user_shell, so we don&#x27;t need to change it.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> INITPROC: Arc&lt;ProcessControlBlock&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">inode</span> = <span class="title function_ invoke__">open_file</span>(<span class="string">&quot;ch8b_initproc&quot;</span>, OpenFlags::RDONLY).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v</span> = inode.<span class="title function_ invoke__">read_all</span>();</span><br><span class="line">        ProcessControlBlock::<span class="title function_ invoke__">new</span>(v.<span class="title function_ invoke__">as_slice</span>())</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过根目录ROOT_INODE打开INIT文件，读取所有文件内容，根据文件内容创建TCB</p>
<h4 id="PCB，进程控制块"><a href="#PCB，进程控制块" class="headerlink" title="PCB，进程控制块"></a>PCB，进程控制块</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ProcessControlBlock</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ProcessControlBlockInner</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> is_zombie: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> memory_set: MemorySet,</span><br><span class="line">    <span class="keyword">pub</span> parent: <span class="type">Option</span>&lt;Weak&lt;ProcessControlBlock&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> children: <span class="type">Vec</span>&lt;Arc&lt;ProcessControlBlock&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="type">i32</span>,</span><br><span class="line">    <span class="keyword">pub</span> fd_table: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> File + <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt;&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> signals: SignalFlags,</span><br><span class="line">    <span class="keyword">pub</span> tasks: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> task_res_allocator: RecycleAllocator,</span><br><span class="line">    <span class="keyword">pub</span> mutex_list: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> Mutex&gt;&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> semaphore_list: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;Arc&lt;Semaphore&gt;&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> condvar_list: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;Arc&lt;Condvar&gt;&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> enable_deadlock: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是TCB的定义，主要包括：</p>
<ul>
<li>pid：进程id，用于标识进程</li>
<li>memory_set：用户的内存地址空间</li>
<li>parent, children： 父子进程关系</li>
<li>fd_table： 文件描述符表</li>
<li>tasks： 线程列表</li>
<li>mutex_list, semaphore_list, condvar_list： 互斥锁、信号量和条件变量列表</li>
</ul>
<p>API:</p>
<ul>
<li><p>new，创建，仅供InitProc使用</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(elf_data: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> Arc&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> (memory_set, ustack_base, entry_point) = MemorySet::<span class="title function_ invoke__">from_elf</span>(elf_data);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pid_handle</span> = <span class="title function_ invoke__">pid_alloc</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = Arc::<span class="title function_ invoke__">new</span>(<span class="keyword">Self</span> &#123;</span><br><span class="line">        pid: pid_handle,</span><br><span class="line">        inner: <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            UPSafeCell::<span class="title function_ invoke__">new</span>(ProcessControlBlockInner &#123;</span><br><span class="line">                is_zombie: <span class="literal">false</span>,</span><br><span class="line">                memory_set,</span><br><span class="line">                parent: <span class="literal">None</span>,</span><br><span class="line">                children: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                exit_code: <span class="number">0</span>,</span><br><span class="line">                fd_table: <span class="built_in">vec!</span>[</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(Stdin)),</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(Stdout)),</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(Stdout)),</span><br><span class="line">                ],</span><br><span class="line">                signals: SignalFlags::<span class="title function_ invoke__">empty</span>(),</span><br><span class="line">                tasks: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                task_res_allocator: RecycleAllocator::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                mutex_list: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                semaphore_list: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                condvar_list: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                enable_deadlock: <span class="literal">false</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task</span> = Arc::<span class="title function_ invoke__">new</span>(TaskControlBlock::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        Arc::<span class="title function_ invoke__">clone</span>(&amp;process),</span><br><span class="line">        ustack_base,</span><br><span class="line">        <span class="literal">true</span>,</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task_inner</span> = task.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx</span> = task_inner.<span class="title function_ invoke__">get_trap_cx</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ustack_top</span> = task_inner.res.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">ustack_top</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">kstack_top</span> = task.kstack.<span class="title function_ invoke__">get_top</span>();</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(task_inner);</span><br><span class="line">    *trap_cx = TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">        entry_point,</span><br><span class="line">        ustack_top,</span><br><span class="line">        KERNEL_SPACE.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">token</span>(),</span><br><span class="line">        kstack_top,</span><br><span class="line">        trap_handler <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    process_inner.tasks.<span class="title function_ invoke__">push</span>(<span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">clone</span>(&amp;task)));</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process_inner);</span><br><span class="line">    <span class="title function_ invoke__">insert_into_pid2process</span>(process.<span class="title function_ invoke__">getpid</span>(), Arc::<span class="title function_ invoke__">clone</span>(&amp;process));</span><br><span class="line">    <span class="title function_ invoke__">add_task</span>(task);</span><br><span class="line">    process</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>创建用户地址空间<br> 将elf文件转换为用户地址空间memory_set::from_elf</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_elf</span>(elf_data: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> (<span class="keyword">Self</span>, <span class="type">usize</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">memory_set</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new_bare</span>();</span><br><span class="line">    memory_set.<span class="title function_ invoke__">map_trampoline</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">elf</span> = xmas_elf::ElfFile::<span class="title function_ invoke__">new</span>(elf_data).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">elf_header</span> = elf.header;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">magic</span> = elf_header.pt1.magic;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(magic, [<span class="number">0x7f</span>, <span class="number">0x45</span>, <span class="number">0x4c</span>, <span class="number">0x46</span>], <span class="string">&quot;invalid elf!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ph_count</span> = elf_header.pt2.<span class="title function_ invoke__">ph_count</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max_end_vpn</span> = <span class="title function_ invoke__">VirtPageNum</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..ph_count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ph</span> = elf.<span class="title function_ invoke__">program_header</span>(i).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">if</span> ph.<span class="title function_ invoke__">get_type</span>().<span class="title function_ invoke__">unwrap</span>() == xmas_elf::program::Type::Load &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">start_va</span>: VirtAddr = (ph.<span class="title function_ invoke__">virtual_addr</span>() <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">end_va</span>: VirtAddr = ((ph.<span class="title function_ invoke__">virtual_addr</span>() + ph.<span class="title function_ invoke__">mem_size</span>()) <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map_perm</span> = MapPermission::U;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">ph_flags</span> = ph.<span class="title function_ invoke__">flags</span>();</span><br><span class="line">            <span class="keyword">if</span> ph_flags.<span class="title function_ invoke__">is_read</span>() &#123;</span><br><span class="line">                map_perm |= MapPermission::R;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ph_flags.<span class="title function_ invoke__">is_write</span>() &#123;</span><br><span class="line">                map_perm |= MapPermission::W;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ph_flags.<span class="title function_ invoke__">is_execute</span>() &#123;</span><br><span class="line">                map_perm |= MapPermission::X;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">map_area</span> = MapArea::<span class="title function_ invoke__">new</span>(start_va, end_va, MapType::Framed, map_perm);</span><br><span class="line">            max_end_vpn = map_area.vpn_range.<span class="title function_ invoke__">get_end</span>();</span><br><span class="line">            memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">                map_area,</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(&amp;elf.input[ph.<span class="title function_ invoke__">offset</span>() <span class="keyword">as</span> <span class="type">usize</span>..(ph.<span class="title function_ invoke__">offset</span>() + ph.<span class="title function_ invoke__">file_size</span>()) <span class="keyword">as</span> <span class="type">usize</span>]),</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">max_end_va</span>: VirtAddr = max_end_vpn.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user_stack_base</span>: <span class="type">usize</span> = max_end_va.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    user_stack_base += PAGE_SIZE;</span><br><span class="line">    (</span><br><span class="line">        memory_set,</span><br><span class="line">        user_stack_base,</span><br><span class="line">        elf.header.pt2.<span class="title function_ invoke__">entry_point</span>() <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/app-as-full.png" alt="用户地址空间"><br> 先映射一个跳板页在高256G空间，一个循环从elf文件中读取数据段以Framed映射方式从0x0地址开始映射<br> 所有数据段映射完成后，插入一个Guard Page，之后的地址作为用户栈底<br> 返回memory_set，用户栈底，程序入口地址</p>
</li>
<li><p>创建主线程TCB<br> 具体内容后面TCB再分析，然后填充了trap_cx，然后通过add_task添加到任务队列中</p>
</li>
</ol>
</li>
<li><p>fork，创建子进程</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fork</span>(<span class="keyword">self</span>: &amp;Arc&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> Arc&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">parent</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">memory_set</span> = MemorySet::<span class="title function_ invoke__">from_existed_user</span>(&amp;parent.memory_set);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pid</span> = <span class="title function_ invoke__">pid_alloc</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">new_fd_table</span>: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> File + <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt;&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">fd</span> <span class="keyword">in</span> parent.fd_table.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(file) = fd &#123;</span><br><span class="line">            new_fd_table.<span class="title function_ invoke__">push</span>(<span class="title function_ invoke__">Some</span>(file.<span class="title function_ invoke__">clone</span>()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            new_fd_table.<span class="title function_ invoke__">push</span>(<span class="literal">None</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">child</span> = Arc::<span class="title function_ invoke__">new</span>(<span class="keyword">Self</span> &#123;</span><br><span class="line">        pid,</span><br><span class="line">        inner: <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            UPSafeCell::<span class="title function_ invoke__">new</span>(ProcessControlBlockInner &#123;</span><br><span class="line">                is_zombie: <span class="literal">false</span>,</span><br><span class="line">                memory_set,</span><br><span class="line">                parent: <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">downgrade</span>(<span class="keyword">self</span>)),</span><br><span class="line">                children: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                exit_code: <span class="number">0</span>,</span><br><span class="line">                fd_table: new_fd_table,</span><br><span class="line">                signals: SignalFlags::<span class="title function_ invoke__">empty</span>(),</span><br><span class="line">                tasks: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                task_res_allocator: RecycleAllocator::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                mutex_list: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                semaphore_list: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                condvar_list: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                enable_deadlock: <span class="literal">false</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    parent.children.<span class="title function_ invoke__">push</span>(Arc::<span class="title function_ invoke__">clone</span>(&amp;child));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task</span> = Arc::<span class="title function_ invoke__">new</span>(TaskControlBlock::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        Arc::<span class="title function_ invoke__">clone</span>(&amp;child),</span><br><span class="line">        parent</span><br><span class="line">            .<span class="title function_ invoke__">get_task</span>(<span class="number">0</span>)</span><br><span class="line">            .<span class="title function_ invoke__">inner_exclusive_access</span>()</span><br><span class="line">            .res</span><br><span class="line">            .<span class="title function_ invoke__">as_ref</span>()</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">            .<span class="title function_ invoke__">ustack_base</span>(),</span><br><span class="line">        <span class="comment">// here we do not allocate trap_cx or ustack again</span></span><br><span class="line">        <span class="comment">// but mention that we allocate a new kstack here</span></span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">child_inner</span> = child.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    child_inner.tasks.<span class="title function_ invoke__">push</span>(<span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">clone</span>(&amp;task)));</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(child_inner);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task_inner</span> = task.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx</span> = task_inner.<span class="title function_ invoke__">get_trap_cx</span>();</span><br><span class="line">    trap_cx.kernel_sp = task.kstack.<span class="title function_ invoke__">get_top</span>();</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(task_inner);</span><br><span class="line">    <span class="title function_ invoke__">insert_into_pid2process</span>(child.<span class="title function_ invoke__">getpid</span>(), Arc::<span class="title function_ invoke__">clone</span>(&amp;child));</span><br><span class="line">    <span class="title function_ invoke__">add_task</span>(task);</span><br><span class="line">    child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建用户地址空间<br> 通过父进程的memory_set创建子进程的memory_set <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_existed_user</span>(user_space: &amp;<span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">memory_set</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new_bare</span>();</span><br><span class="line">    memory_set.<span class="title function_ invoke__">map_trampoline</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">area</span> <span class="keyword">in</span> user_space.areas.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">new_area</span> = MapArea::<span class="title function_ invoke__">from_another</span>(area);</span><br><span class="line">        memory_set.<span class="title function_ invoke__">push</span>(new_area, <span class="literal">None</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">vpn</span> <span class="keyword">in</span> area.vpn_range &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">src_ppn</span> = user_space.<span class="title function_ invoke__">translate</span>(vpn).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">dst_ppn</span> = memory_set.<span class="title function_ invoke__">translate</span>(vpn).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">            dst_ppn</span><br><span class="line">                .<span class="title function_ invoke__">get_bytes_array</span>()</span><br><span class="line">                .<span class="title function_ invoke__">copy_from_slice</span>(src_ppn.<span class="title function_ invoke__">get_bytes_array</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memory_set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 需要手动映射一下跳板页，之后将父进程中的逻辑段添加到子进程的memory_set中，并且将父进程逻辑段物理页中的数据copy到新物理页中</li>
<li>创建子进程的主线程<br> 这里不用再次创建trap_cx和ustack，因为之前父进程已经创建了映射在memory_set中了<br> 但是这里需要手动创建一个内核栈<br> 仅修改trap_cx的kernel_sp，然后将新的主线程add_task加入调度</li>
</ol>
</li>
<li><p>exec，执行新文件</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exec</span>(<span class="keyword">self</span>: &amp;Arc&lt;<span class="keyword">Self</span>&gt;, elf_data: &amp;[<span class="type">u8</span>], args: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> (memory_set, ustack_base, entry_point) = MemorySet::<span class="title function_ invoke__">from_elf</span>(elf_data);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_token</span> = memory_set.<span class="title function_ invoke__">token</span>();</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">inner_exclusive_access</span>().memory_set = memory_set;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">inner_exclusive_access</span>().<span class="title function_ invoke__">get_task</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">task_inner</span> = task.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    task_inner.res.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>().ustack_base = ustack_base;</span><br><span class="line">    task_inner.res.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">alloc_user_res</span>();</span><br><span class="line">    task_inner.trap_cx_ppn = task_inner.res.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">trap_cx_ppn</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user_sp</span> = task_inner.res.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">ustack_top</span>();</span><br><span class="line">    user_sp -= (args.<span class="title function_ invoke__">len</span>() + <span class="number">1</span>) * core::mem::size_of::&lt;<span class="type">usize</span>&gt;();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">argv_base</span> = user_sp;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">argv</span>: <span class="type">Vec</span>&lt;_&gt; = (<span class="number">0</span>..=args.<span class="title function_ invoke__">len</span>())</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|arg| &#123;</span><br><span class="line">            <span class="title function_ invoke__">translated_refmut</span>(</span><br><span class="line">                new_token,</span><br><span class="line">                (argv_base + arg * core::mem::size_of::&lt;<span class="type">usize</span>&gt;()) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">usize</span>,</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    *argv[args.<span class="title function_ invoke__">len</span>()] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..args.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        user_sp -= args[i].<span class="title function_ invoke__">len</span>() + <span class="number">1</span>;</span><br><span class="line">        *argv[i] = user_sp;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = user_sp;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> args[i].<span class="title function_ invoke__">as_bytes</span>() &#123;</span><br><span class="line">            *<span class="title function_ invoke__">translated_refmut</span>(new_token, p <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>) = *c;</span><br><span class="line">            p += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *<span class="title function_ invoke__">translated_refmut</span>(new_token, p <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>) = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    user_sp -= user_sp % core::mem::size_of::&lt;<span class="type">usize</span>&gt;();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">trap_cx</span> = TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">        entry_point,</span><br><span class="line">        user_sp,</span><br><span class="line">        KERNEL_SPACE.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">token</span>(),</span><br><span class="line">        task.kstack.<span class="title function_ invoke__">get_top</span>(),</span><br><span class="line">        trap_handler <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">    );</span><br><span class="line">    trap_cx.x[<span class="number">10</span>] = args.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    trap_cx.x[<span class="number">11</span>] = argv_base;</span><br><span class="line">    *task_inner.<span class="title function_ invoke__">get_trap_cx</span>() = trap_cx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>替换用户地址空间<br> 通过elf_data创建新的用户地址空间，并替换原有的memory_set<br> 此时就需要创建新的ustack和trap_cx了，因为旧的已经被替换。</li>
<li>压入参数<br> <img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/user-stack-cmdargs.png" alt="参数"><br> 如上图所示：<br> 从栈顶开始即高地址开始，先压入参数在用户栈上的开始地址，再将参数数据压入</li>
<li>修改trap_cx<br> 先app_init_context创建新trap_cx，然后将x[10],x[11]修改为argc和argv</li>
</ol>
</li>
</ul>
<h4 id="TCB，任务控制块"><a href="#TCB，任务控制块" class="headerlink" title="TCB，任务控制块"></a>TCB，任务控制块</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlock</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> process: Weak&lt;ProcessControlBlock&gt;,</span><br><span class="line">    <span class="keyword">pub</span> kstack: KernelStack,</span><br><span class="line">    inner: UPSafeCell&lt;TaskControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlockInner</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> res: <span class="type">Option</span>&lt;TaskUserRes&gt;,</span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum,</span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> stride: TaskStride,</span><br><span class="line">    <span class="keyword">pub</span> mutex_cnt: <span class="type">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> semaphore_cnt: BTreeMap&lt;<span class="type">usize</span>, <span class="type">isize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面为TCB的定义，关键的字段如下：</p>
<ul>
<li>kstack：内核栈，每个线程都有独立的内核栈</li>
<li>res：线程资源  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskUserRes</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> tid: <span class="type">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> ustack_base: <span class="type">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> process: Weak&lt;ProcessControlBlock&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>tid：线程id</li>
<li>ustack_base：用户栈底</li>
</ul>
</li>
<li>task_cx：线程上下文，用于切换线程  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskContext</span> &#123;</span><br><span class="line">    ra: <span class="type">usize</span>,</span><br><span class="line">    sp: <span class="type">usize</span>,</span><br><span class="line">    s: [<span class="type">usize</span>; <span class="number">12</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  包括ra为返回地址，sp为栈顶，s为保存的寄存器</li>
<li>task_status：线程状态，包括running, ready, blocked</li>
<li>exit_code： 线程退出码</li>
</ul>
<p>API：</p>
<ul>
<li>new，创建TCB  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(</span><br><span class="line">    process: Arc&lt;ProcessControlBlock&gt;,</span><br><span class="line">    ustack_base: <span class="type">usize</span>,</span><br><span class="line">    alloc_user_res: <span class="type">bool</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = TaskUserRes::<span class="title function_ invoke__">new</span>(Arc::<span class="title function_ invoke__">clone</span>(&amp;process), ustack_base, alloc_user_res);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx_ppn</span> = res.<span class="title function_ invoke__">trap_cx_ppn</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">kstack</span> = <span class="title function_ invoke__">kstack_alloc</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">kstack_top</span> = kstack.<span class="title function_ invoke__">get_top</span>();</span><br><span class="line">    <span class="keyword">Self</span> &#123;</span><br><span class="line">        process: Arc::<span class="title function_ invoke__">downgrade</span>(&amp;process),</span><br><span class="line">        kstack,</span><br><span class="line">        inner: <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            UPSafeCell::<span class="title function_ invoke__">new</span>(TaskControlBlockInner &#123;</span><br><span class="line">                res: <span class="title function_ invoke__">Some</span>(res),</span><br><span class="line">                trap_cx_ppn,</span><br><span class="line">                task_cx: TaskContext::<span class="title function_ invoke__">goto_trap_return</span>(kstack_top),</span><br><span class="line">                task_status: TaskStatus::Ready,</span><br><span class="line">                exit_code: <span class="literal">None</span>,</span><br><span class="line">                stride: TaskStride::<span class="title function_ invoke__">default</span>(),</span><br><span class="line">                mutex_cnt: <span class="number">0</span>,</span><br><span class="line">                semaphore_cnt: BTreeMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>创建用户资源</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(</span><br><span class="line">    process: Arc&lt;ProcessControlBlock&gt;,</span><br><span class="line">    ustack_base: <span class="type">usize</span>,</span><br><span class="line">    alloc_user_res: <span class="type">bool</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tid</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>().<span class="title function_ invoke__">alloc_tid</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task_user_res</span> = <span class="keyword">Self</span> &#123;</span><br><span class="line">        tid,</span><br><span class="line">        ustack_base,</span><br><span class="line">        process: Arc::<span class="title function_ invoke__">downgrade</span>(&amp;process),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> alloc_user_res &#123;</span><br><span class="line">        task_user_res.<span class="title function_ invoke__">alloc_user_res</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    task_user_res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 先分配tid，再根据是否需要分配资源来创建用户资源<code>这里就是为了区分fork</code><br> 用户资源包括了：ustack和trap_cx</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">alloc_user_res</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="keyword">self</span>.process.<span class="title function_ invoke__">upgrade</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ustack_bottom</span> = <span class="title function_ invoke__">ustack_bottom_from_tid</span>(<span class="keyword">self</span>.ustack_base, <span class="keyword">self</span>.tid);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ustack_top</span> = ustack_bottom + USER_STACK_SIZE;</span><br><span class="line">    process_inner.memory_set.<span class="title function_ invoke__">insert_framed_area</span>(</span><br><span class="line">        ustack_bottom.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        ustack_top.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        MapPermission::R | MapPermission::W | MapPermission::U,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// alloc trap_cx</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx_bottom</span> = <span class="title function_ invoke__">trap_cx_bottom_from_tid</span>(<span class="keyword">self</span>.tid);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx_top</span> = trap_cx_bottom + PAGE_SIZE;</span><br><span class="line">    process_inner.memory_set.<span class="title function_ invoke__">insert_framed_area</span>(</span><br><span class="line">        trap_cx_bottom.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        trap_cx_top.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        MapPermission::R | MapPermission::W,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 再用户地址空间上分配ustack和trap_cx<br> 至此用户地址空间如下图：<br> <img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/app-as-full.png" alt="用户地址空间"><br> 用户栈处于低256GB空间，依次排布，中间间隔一个guard_page，<br> trap_cx处于高256GB空间，依次排布，中间间隔一个guard_page</p>
</li>
<li><p>创建内核栈<br> <img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/kernel-as-high.png" alt="内核地址空间">]<br> 如上图所示，内核栈处于KERNEL_SPACE的高256GB空间，依次排布，中间间隔一个guard_page</p>
</li>
<li><p>设置task_cx</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">goto_trap_return</span>(kstack_ptr: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">Self</span> &#123;</span><br><span class="line">        ra: trap_return <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">        sp: kstack_ptr,</span><br><span class="line">        s: [<span class="number">0</span>; <span class="number">12</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 创建task_cx，其中ra为trap_return函数的地址，sp为内核栈顶，s全空</p>
</li>
</ol>
</li>
</ul>
<h4 id="创建INITPROC"><a href="#创建INITPROC" class="headerlink" title="创建INITPROC"></a>创建INITPROC</h4><p>至此回顾一下Init进程的创建：</p>
<ul>
<li>通过elf_data创建用户地址空间memory_set，<br>  包括跳板页，.text，.rodata，.data，.bss</li>
<li>创建主线程TCB<br>  分配内核栈kstack，用户栈ustack</li>
<li>设置task_cx<br>  将其设置为ra: trap_return, sp: kstack_top, 其他寄存器为0</li>
<li>设置trap_cx<br>  将entry_point指向init入口，<br>  sp为ustack_top<br>  kernel_satp指向KERNEL_SPACE<br>  kernel_sp指向当前线程kstack_top<br>  trap_handler指向trap_handler</li>
<li>将主线程加入调度，将process加入pid管理</li>
</ul>
<h2 id="初次调度任务"><a href="#初次调度任务" class="headerlink" title="初次调度任务"></a>初次调度任务</h2><p>至此创建完Init进程，并将Init的主线程加入调度，可以开始调度任务了。</p>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">    current: <span class="type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">    idle_task_cx: TaskContext,</span><br><span class="line">&#125;</span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> PROCESSOR: UPSafeCell&lt;Processor&gt; = <span class="keyword">unsafe</span> &#123; UPSafeCell::<span class="title function_ invoke__">new</span>(Processor::<span class="title function_ invoke__">new</span>()) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>current：当前正在执行的线程</li>
<li>idle_task_cx：空闲流<br>关于执行流和空闲流理解：<br>内核本身调度时是有上下文的，比如此时的内核栈是再KERNEL_SPACE的低256GB空间中。<br>当切换到执行流时，内核的上下文也要切换到执行流的上下文，比如执行流的内核栈是再KERNEL_SPACE的高256GB空间中。</li>
</ul>
<p>API:</p>
<ul>
<li>new  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">Self</span> &#123;</span><br><span class="line">        current: <span class="literal">None</span>,</span><br><span class="line">        idle_task_cx: TaskContext::<span class="title function_ invoke__">zero_init</span>(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  初始化全空current和idle_task_cx</li>
<li>take_current  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">take_current</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.current.<span class="title function_ invoke__">take</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  消费current任务，拿到current的所有权</li>
<li>current  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">current</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.current.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">map</span>(Arc::clone)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  仅获取current的引用，本身所有权仍属于Processor</li>
</ul>
<h3 id="线程管理器"><a href="#线程管理器" class="headerlink" title="线程管理器"></a>线程管理器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line">    ready_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">    stop_task: <span class="type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> TASK_MANAGER: UPSafeCell&lt;TaskManager&gt; =</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; UPSafeCell::<span class="title function_ invoke__">new</span>(TaskManager::<span class="title function_ invoke__">new</span>()) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ready_queue：就绪队列</li>
<li>stop_task：停止中任务</li>
</ul>
<p>API:</p>
<ul>
<li>new, 创建  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">Self</span> &#123;</span><br><span class="line">        ready_queue: VecDeque::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        stop_task: <span class="literal">None</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  初始化ready_queue为VecDeque，stop_task为None</li>
<li>add, 添加任务  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, task: Arc&lt;TaskControlBlock&gt;) &#123;</span><br><span class="line">    <span class="keyword">self</span>.ready_queue.<span class="title function_ invoke__">push_back</span>(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  添加任务到ready_queue</li>
<li>remove, 移除任务  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fetch</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.ready_queue.<span class="title function_ invoke__">pop_front</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  移除ready_queue中的第一个任务</li>
<li>add_stop, 添加停止中任务  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_stop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, task: Arc&lt;TaskControlBlock&gt;) &#123;</span><br><span class="line">    <span class="keyword">self</span>.stop_task = <span class="title function_ invoke__">Some</span>(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="调度任务"><a href="#调度任务" class="headerlink" title="调度任务"></a>调度任务</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run_tasks</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">processor</span> = PROCESSOR.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = <span class="title function_ invoke__">fetch_task</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">idle_task_cx_ptr</span> = processor.<span class="title function_ invoke__">get_idle_task_cx_ptr</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">task_inner</span> = task.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">next_task_cx_ptr</span> = &amp;task_inner.task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line">            task_inner.task_status = TaskStatus::Running;</span><br><span class="line">            <span class="title function_ invoke__">drop</span>(task_inner);</span><br><span class="line">            processor.current = <span class="title function_ invoke__">Some</span>(task);</span><br><span class="line">            <span class="title function_ invoke__">drop</span>(processor);</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                __switch(idle_task_cx_ptr, next_task_cx_ptr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            warn!(<span class="string">&quot;no tasks available in run_tasks&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获取就绪任务<br> 通过fetch_task，从TASK_MANAGER中获取就绪任务</li>
<li>task所有权传递<br> Processor中current为设置为新任务，丢弃之前的current<br> task的所有权从TASK_MANAGER-&gt;PROCESSOR</li>
<li>切换上下文<br> 通过__switch，将当前即idle的上下文切换到新任务的上下文</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">schedule</span>(switched_task_cx_ptr: *<span class="keyword">mut</span> TaskContext) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">processor</span> = PROCESSOR.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">idle_task_cx_ptr</span> = processor.<span class="title function_ invoke__">get_idle_task_cx_ptr</span>();</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(processor);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __switch(switched_task_cx_ptr, idle_task_cx_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>schedule，将当前任务切换到idle流上</p>
<h3 id="任务上下文切换"><a href="#任务上下文切换" class="headerlink" title="任务上下文切换"></a>任务上下文切换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_SN n</span><br><span class="line">    sd s\n, (\n+2)*8(a0)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_SN n</span><br><span class="line">    ld s\n, (\n+2)*8(a1)</span><br><span class="line">.endm</span><br><span class="line">    .section .text</span><br><span class="line">    .globl __switch</span><br><span class="line">__switch:</span><br><span class="line">    # __switch(</span><br><span class="line">    #     current_task_cx_ptr: *mut TaskContext,</span><br><span class="line">    #     next_task_cx_ptr: *const TaskContext</span><br><span class="line">    # )</span><br><span class="line">    # save kernel stack of current task</span><br><span class="line">    sd sp, 8(a0)</span><br><span class="line">    # save ra &amp; s0~s11 of current execution</span><br><span class="line">    sd ra, 0(a0)</span><br><span class="line">    .set n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        SAVE_SN %n</span><br><span class="line">        .set n, n + 1</span><br><span class="line">    .endr</span><br><span class="line">    # restore ra &amp; s0~s11 of next execution</span><br><span class="line">    ld ra, 0(a1)</span><br><span class="line">    .set n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        LOAD_SN %n</span><br><span class="line">        .set n, n + 1</span><br><span class="line">    .endr</span><br><span class="line">    # restore kernel stack of next task</span><br><span class="line">    ld sp, 8(a1)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>回顾TaskContext结构体：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskContext</span> &#123;</span><br><span class="line">    ra: <span class="type">usize</span>,</span><br><span class="line">    sp: <span class="type">usize</span>,</span><br><span class="line">    s: [<span class="type">usize</span>; <span class="number">12</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>a0为idle的task_cx，数值全0<br>a1为当前正在执行的task_cx，此时为Init，</p>
<ul>
<li>ra为trap_return,</li>
<li>sp为init的kstack_top</li>
<li>s全为0<br>__switch函数，先将当前idle的上下文保存在Processor的idle_task_cx，<br>之后从task_cx中将寄存器值加载进来，<br>至此内核上下文切换完成，接下来通过ret跳转到ra，即trap_return。</li>
</ul>
<h2 id="内核态和用户态切换"><a href="#内核态和用户态切换" class="headerlink" title="内核态和用户态切换"></a>内核态和用户态切换</h2><h3 id="初次进入用户态"><a href="#初次进入用户态" class="headerlink" title="初次进入用户态"></a>初次进入用户态</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">set_user_trap_entry</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        stvec::<span class="title function_ invoke__">write</span>(TRAMPOLINE <span class="keyword">as</span> <span class="type">usize</span>, TrapMode::Direct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap_return</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">set_user_trap_entry</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx_user_va</span> = <span class="title function_ invoke__">current_trap_cx_user_va</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user_satp</span> = <span class="title function_ invoke__">current_user_token</span>();</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">__alltraps</span>();</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">__restore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">restore_va</span> = __restore <span class="keyword">as</span> <span class="type">usize</span> - __alltraps <span class="keyword">as</span> <span class="type">usize</span> + TRAMPOLINE;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">&quot;fence.i&quot;</span>,</span><br><span class="line">            <span class="string">&quot;jr &#123;restore_va&#125;&quot;</span>,         <span class="comment">// jump to new addr of __restore asm function</span></span><br><span class="line">            restore_va = <span class="title function_ invoke__">in</span>(reg) restore_va,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;a0&quot;</span>) trap_cx_user_va,      <span class="comment">// a0 = virt addr of Trap Context</span></span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;a1&quot;</span>) user_satp,        <span class="comment">// a1 = phy addr of usr page table</span></span><br><span class="line">            <span class="title function_ invoke__">options</span>(noreturn)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>设置用户态的中断入口<br> 这里就是__alltraps的地址，用户态中断后就会到__alltraps中</p>
</li>
<li><p>跳转到__restore<br> 先计算restore的虚拟地址，然后设置a0为当前任务的trap_cx地址（用户地址空间的高256GB中），a1为用户地址空间satp</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TrapContext</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> x: [<span class="type">usize</span>; <span class="number">32</span>],</span><br><span class="line">    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line">    <span class="keyword">pub</span> sepc: <span class="type">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> kernel_satp: <span class="type">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> kernel_sp: <span class="type">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> trap_handler: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 此时的trap_cx内容如下：</p>
<ul>
<li>x: 均为0</li>
<li>sstatus: 设置了SPP::User</li>
<li>sepc：为init的entry_ptr</li>
<li>kernel_satp：内核地址空间satp</li>
<li>kernel_sp：为init的kstack_top</li>
<li>trap_handler：即handler_handler地址</li>
</ul>
</li>
<li><p>准备进入用户态__restore</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">__restore:</span><br><span class="line">    # a0: *TrapContext in user space(Constant); a1: user space token</span><br><span class="line">    # switch to user space</span><br><span class="line">    csrw satp, a1</span><br><span class="line">    sfence.vma</span><br><span class="line">    csrw sscratch, a0</span><br><span class="line">    mv sp, a0</span><br><span class="line">    # now sp points to TrapContext in user space, start restoring based on it</span><br><span class="line">    # restore sstatus/sepc</span><br><span class="line">    ld t0, 32*8(sp)</span><br><span class="line">    ld t1, 33*8(sp)</span><br><span class="line">    csrw sstatus, t0</span><br><span class="line">    csrw sepc, t1</span><br><span class="line">    # restore general purpose registers except x0/sp/tp</span><br><span class="line">    ld x1, 1*8(sp)</span><br><span class="line">    ld x3, 3*8(sp)</span><br><span class="line">    .set n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        LOAD_GP %n</span><br><span class="line">        .set n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    # back to user stack</span><br><span class="line">    ld sp, 2*8(sp)</span><br><span class="line">    sret</span><br></pre></td></tr></table></figure>
<ul>
<li>先切换mmu，使用户地址空间的satp，sfence.vma刷新tlb</li>
<li>保存sscratch为trap_cx的地址</li>
<li>之后从trap_cx中恢复sstatus和sepc</li>
<li>恢复通用寄存器除了x0&#x2F;sp&#x2F;tp，这里一开始全为0</li>
<li>最后恢复sp，刚开始也是0</li>
<li>调用sret，进入用户态</li>
</ul>
</li>
</ol>
<h3 id="返回内核态"><a href="#返回内核态" class="headerlink" title="返回内核态"></a>返回内核态</h3><p>在进入用户态之前，设置了中断处理器，当用户态发生中断时，会调用__alltraps。进入内核态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__alltraps:</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    # now sp-&gt;*TrapContext in user space, sscratch-&gt;user stack</span><br><span class="line">    # save other general purpose registers</span><br><span class="line">    sd x1, 1*8(sp)</span><br><span class="line">    # skip sp(x2), we will save it later</span><br><span class="line">    sd x3, 3*8(sp)</span><br><span class="line">    # skip tp(x4), application does not use it</span><br><span class="line">    # save x5~x31</span><br><span class="line">    .set n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        SAVE_GP %n</span><br><span class="line">        .set n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    # we can use t0/t1/t2 freely, because they have been saved in TrapContext</span><br><span class="line">    csrr t0, sstatus</span><br><span class="line">    csrr t1, sepc</span><br><span class="line">    sd t0, 32*8(sp)</span><br><span class="line">    sd t1, 33*8(sp)</span><br><span class="line">    # read user stack from sscratch and save it in TrapContext</span><br><span class="line">    csrr t2, sscratch</span><br><span class="line">    sd t2, 2*8(sp)</span><br><span class="line">    # load kernel_satp into t0</span><br><span class="line">    ld t0, 34*8(sp)</span><br><span class="line">    # load trap_handler into t1</span><br><span class="line">    ld t1, 36*8(sp)</span><br><span class="line">    # move to kernel_sp</span><br><span class="line">    ld sp, 35*8(sp)</span><br><span class="line">    # switch to kernel space</span><br><span class="line">    csrw satp, t0</span><br><span class="line">    sfence.vma</span><br><span class="line">    # jump to trap_handler</span><br><span class="line">    jr t1</span><br></pre></td></tr></table></figure>
<ul>
<li>交换sp, sscratch<br>  上面进入用户态前，sscratch保存了trap_cx的地址。<br>  交换后，sp为trap_cx的地址，sscratch为user stack</li>
<li>保存通用寄存器跳过x2,x4</li>
<li>保存sstatus和sepc</li>
<li>将sscratch保存到trap_cx的sp中，因为上面交换后，sscratch即用户栈</li>
<li>从trap_cx中恢复kernel_satp和kernel_sp</li>
<li>切换到内核地址空间</li>
<li>跳转到trap_handler<br>至此就切换到了内核态，此时的内核栈是Init的kstack，接下来就是中断处理</li>
</ul>
<h3 id="再次进入用户态"><a href="#再次进入用户态" class="headerlink" title="再次进入用户态"></a>再次进入用户态</h3><p>以系统调用为例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Trap::<span class="title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">        <span class="comment">// jump to next instruction anyway</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cx</span> = <span class="title function_ invoke__">current_trap_cx</span>();</span><br><span class="line">        cx.sepc += <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// get system call return value</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">syscall</span>(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>], cx.x[<span class="number">13</span>]]);</span><br><span class="line">        <span class="comment">// cx is changed during sys_exec, so we have to call it again</span></span><br><span class="line">        cx = <span class="title function_ invoke__">current_trap_cx</span>();</span><br><span class="line">        cx.x[<span class="number">10</span>] = result <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">trap_return</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>跳过当前ecall指令，ecall指令长度4</li>
<li>重新获取trap_cx，设置x10为返回值，因为sys_exec会修改trap_cx，所以再次获取</li>
<li>调用trap_return，同第一次进入用户态一样，只不过此时trap_cx中已经保留用户态的上下文信息</li>
</ol>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MutexBlocking</span> &#123;</span><br><span class="line">    inner: UPSafeCell&lt;MutexBlockingInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MutexBlockingInner</span> &#123;</span><br><span class="line">    locked: <span class="type">bool</span>,</span><br><span class="line">    wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>locked，表示是否被锁住</li>
<li>wait_queue，表示等待的队列</li>
</ul>
<p>API:</p>
<ul>
<li>lock  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutex_inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">if</span> mutex_inner.locked &#123;</span><br><span class="line">        mutex_inner.wait_queue.<span class="title function_ invoke__">push_back</span>(<span class="title function_ invoke__">current_task</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(mutex_inner);</span><br><span class="line">        <span class="title function_ invoke__">block_current_and_run_next</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mutex_inner.locked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判断是否被锁住，如果被锁住，则将当前任务加入等待队列，并阻塞当前任务</li>
<li>如果没有被锁住，则直接将锁标记为true</li>
</ol>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">block_current_and_run_next</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task</span> = <span class="title function_ invoke__">take_current_task</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">task_inner</span> = task.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task_cx_ptr</span> = &amp;<span class="keyword">mut</span> task_inner.task_cx <span class="keyword">as</span> *<span class="keyword">mut</span> TaskContext;</span><br><span class="line">    task_inner.task_status = TaskStatus::Blocked;</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(task_inner);</span><br><span class="line">    <span class="title function_ invoke__">schedule</span>(task_cx_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  获取当前任务所有权，设置为阻塞状态，并通过schedule切换到idle流</p>
</li>
<li>unlock  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">unlock</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutex_inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(mutex_inner.locked);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(waking_task) = mutex_inner.wait_queue.<span class="title function_ invoke__">pop_front</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">wakeup_task</span>(waking_task);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mutex_inner.locked = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判断等待队列是否为空，不空唤醒等待队列中的第一个任务</li>
<li>如果为空，则将锁标记为false</li>
</ol>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">wakeup_task</span>(task: Arc&lt;TaskControlBlock&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">task_inner</span> = task.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    task_inner.task_status = TaskStatus::Ready;</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(task_inner);</span><br><span class="line">    <span class="title function_ invoke__">add_task</span>(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  将任务加入就绪队列</p>
</li>
</ul>
<p>由于锁资源是进程共享的，所有保存在PCB中</p>
<h4 id="互斥锁创建"><a href="#互斥锁创建" class="headerlink" title="互斥锁创建"></a>互斥锁创建</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_mutex_create</span>(blocking: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex</span>: <span class="type">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> Mutex&gt;&gt; = <span class="keyword">if</span> !blocking &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(MutexSpin::<span class="title function_ invoke__">new</span>()))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(MutexBlocking::<span class="title function_ invoke__">new</span>()))</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(id) = process_inner</span><br><span class="line">        .mutex_list</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">enumerate</span>()</span><br><span class="line">        .<span class="title function_ invoke__">find</span>(|(_, item)| item.<span class="title function_ invoke__">is_none</span>())</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|(id, _)| id)</span><br><span class="line">    &#123;</span><br><span class="line">        process_inner.mutex_list[id] = mutex;</span><br><span class="line">        id <span class="keyword">as</span> <span class="type">isize</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        process_inner.mutex_list.<span class="title function_ invoke__">push</span>(mutex);</span><br><span class="line">        process_inner.mutex_list.<span class="title function_ invoke__">len</span>() <span class="keyword">as</span> <span class="type">isize</span> - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，创建一个Mutex，保存在PCB的mutex_list中</p>
<h4 id="互斥锁使用"><a href="#互斥锁使用" class="headerlink" title="互斥锁使用"></a>互斥锁使用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_mutex_lock</span>(mutex_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">clone</span>(process_inner.mutex_list[mutex_id].<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process_inner);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process);</span><br><span class="line">    mutex.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_mutex_unlock</span>(mutex_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">clone</span>(process_inner.mutex_list[mutex_id].<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process_inner);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process);</span><br><span class="line">    mutex.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用也比较简单，通过mutex_id获取Mutex，然后调用lock和unlock<br>现在讨论一下整个过程中的程序行为：</p>
<ol>
<li>创建互斥锁，创建一个Mutex，保存在PCB的mutex_list中</li>
<li>线程1调用lock，此时locked为true</li>
<li>线程2调用lock，发现locked为true，tcb保存在mutex的wait_queue中，将执行流中的current保存在内核栈上</li>
<li>线程1调用unlock，tcb从mutex的wait_queue中取出，加入TASK_MANAGER</li>
<li>线程2恢复执行，回到block_current_and_run_next中，返回task被丢弃，仅存在一份在Processor<br>整个过程中task的所有权从Processor中转移到mutex_list的wait_queue中，然后重新加入到TASK_MANAGER中，最后重新会到Processor中</li>
</ol>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Semaphore</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> inner: UPSafeCell&lt;SemaphoreInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SemaphoreInner</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> count: <span class="type">isize</span>,</span><br><span class="line">    <span class="keyword">pub</span> wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>count，表示信号量的值</li>
<li>wait_queue，表示等待的队列</li>
</ul>
<p>API:</p>
<ul>
<li>up，V操作  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">up</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    inner.count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> inner.count &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = inner.wait_queue.<span class="title function_ invoke__">pop_front</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">wakeup_task</span>(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>将count加1</li>
<li>如果count小于等于0，则从wait_queue中取出一个任务，唤醒该任务<br> 因为P操作是count-1，count小于0说明有任务在等待</li>
</ol>
</li>
<li>down，P操作  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">down</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    inner.count -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> inner.count &lt; <span class="number">0</span> &#123;</span><br><span class="line">        inner.wait_queue.<span class="title function_ invoke__">push_back</span>(<span class="title function_ invoke__">current_task</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(inner);</span><br><span class="line">        <span class="title function_ invoke__">block_current_and_run_next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>将count减1，如果count小于0，则将当前任务加入等待队列，并阻塞当前任务</li>
</ol>
</li>
</ul>
<p>实际syscall_调用也比较简单，不再赘述</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_semaphore_create</span>(res_count: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id</span> = <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(id) = process_inner</span><br><span class="line">        .semaphore_list</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">enumerate</span>()</span><br><span class="line">        .<span class="title function_ invoke__">find</span>(|(_, item)| item.<span class="title function_ invoke__">is_none</span>())</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|(id, _)| id)</span><br><span class="line">    &#123;</span><br><span class="line">        process_inner.semaphore_list[id] = <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(Semaphore::<span class="title function_ invoke__">new</span>(res_count)));</span><br><span class="line">        id</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        process_inner</span><br><span class="line">            .semaphore_list</span><br><span class="line">            .<span class="title function_ invoke__">push</span>(<span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(Semaphore::<span class="title function_ invoke__">new</span>(res_count))));</span><br><span class="line">        process_inner.semaphore_list.<span class="title function_ invoke__">len</span>() - <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    id <span class="keyword">as</span> <span class="type">isize</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// semaphore up syscall</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_semaphore_up</span>(sem_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sem</span> = Arc::<span class="title function_ invoke__">clone</span>(process_inner.semaphore_list[sem_id].<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process_inner);</span><br><span class="line">    sem.<span class="title function_ invoke__">up</span>();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// semaphore down syscall</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_semaphore_down</span>(sem_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sem</span> = Arc::<span class="title function_ invoke__">clone</span>(process_inner.semaphore_list[sem_id].<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process_inner);</span><br><span class="line">    sem.<span class="title function_ invoke__">down</span>();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> inner: UPSafeCell&lt;CondvarInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CondvarInner</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue，表示等待的队列</li>
</ul>
<p>API:</p>
<ul>
<li>signal  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">signal</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = inner.wait_queue.<span class="title function_ invoke__">pop_front</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">wakeup_task</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  唤醒wait_queue中的第一个任务</li>
<li>wait  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">wait</span>(&amp;<span class="keyword">self</span>, mutex: Arc&lt;<span class="keyword">dyn</span> Mutex&gt;) &#123;</span><br><span class="line">    mutex.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    inner.wait_queue.<span class="title function_ invoke__">push_back</span>(<span class="title function_ invoke__">current_task</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(inner);</span><br><span class="line">    <span class="title function_ invoke__">block_current_and_run_next</span>();</span><br><span class="line">    mutex.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  解锁mutex，将当前task加入wait_queue，阻塞当前task调度下一个任务<br>  加锁mutex</li>
</ul>
<p>对应的syscall如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_condvar_create</span>() <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id</span> = <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(id) = process_inner</span><br><span class="line">        .condvar_list</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">enumerate</span>()</span><br><span class="line">        .<span class="title function_ invoke__">find</span>(|(_, item)| item.<span class="title function_ invoke__">is_none</span>())</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|(id, _)| id)</span><br><span class="line">    &#123;</span><br><span class="line">        process_inner.condvar_list[id] = <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(Condvar::<span class="title function_ invoke__">new</span>()));</span><br><span class="line">        id</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        process_inner</span><br><span class="line">            .condvar_list</span><br><span class="line">            .<span class="title function_ invoke__">push</span>(<span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(Condvar::<span class="title function_ invoke__">new</span>())));</span><br><span class="line">        process_inner.condvar_list.<span class="title function_ invoke__">len</span>() - <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    id <span class="keyword">as</span> <span class="type">isize</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// condvar signal syscall</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_condvar_signal</span>(condvar_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">condvar</span> = Arc::<span class="title function_ invoke__">clone</span>(process_inner.condvar_list[condvar_id].<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process_inner);</span><br><span class="line">    condvar.<span class="title function_ invoke__">signal</span>();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// condvar wait syscall</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_condvar_wait</span>(condvar_id: <span class="type">usize</span>, mutex_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">condvar</span> = Arc::<span class="title function_ invoke__">clone</span>(process_inner.condvar_list[condvar_id].<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">clone</span>(process_inner.mutex_list[mutex_id].<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process_inner);</span><br><span class="line">    condvar.<span class="title function_ invoke__">wait</span>(mutex);</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://rubick-hqm.github.io/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="cm9wq05f90001ogvjc4623kdn" data-title="操作系统_总结" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2025/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">操作系统_文件系统</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统_总结</a>
          </li>
        
          <li>
            <a href="/2025/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">操作系统_文件系统</a>
          </li>
        
          <li>
            <a href="/2025/04/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">操作系统_进程及进程管理</a>
          </li>
        
          <li>
            <a href="/2025/03/02/serde/">serde的使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>