<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>操作系统_文件系统 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="以下是参加清华大学2025 春夏季开源操作系统训练营学习blog。本节关于操作系统的文件系统相关的内容。 API方向我们先从API的方向来分析文件系统，底层先当作一个黑盒，先看看如何使用文件系统来操作文件。 EasyFileSystem数据结构123456789101112131415pub struct EasyFileSystem &#123;    &#x2F;&#x2F;&#x2F;Real device    pub">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统_文件系统">
<meta property="og:url" content="https://rubick-hqm.github.io/2025/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="以下是参加清华大学2025 春夏季开源操作系统训练营学习blog。本节关于操作系统的文件系统相关的内容。 API方向我们先从API的方向来分析文件系统，底层先当作一个黑盒，先看看如何使用文件系统来操作文件。 EasyFileSystem数据结构123456789101112131415pub struct EasyFileSystem &#123;    &#x2F;&#x2F;&#x2F;Real device    pub">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-04-19T04:37:54.366Z">
<meta property="article:modified_time" content="2025-04-20T07:00:50.306Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://rubick-hqm.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-操作系统_文件系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2025-04-19T04:37:54.366Z" itemprop="datePublished">2025-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      操作系统_文件系统
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>以下是参加清华大学2025 春夏季开源操作系统训练营学习blog。<br>本节关于操作系统的文件系统相关的内容。</p>
<h1 id="API方向"><a href="#API方向" class="headerlink" title="API方向"></a>API方向</h1><p>我们先从API的方向来分析文件系统，底层先当作一个黑盒，先看看如何使用文件系统来操作文件。</p>
<h2 id="EasyFileSystem数据结构"><a href="#EasyFileSystem数据结构" class="headerlink" title="EasyFileSystem数据结构"></a>EasyFileSystem数据结构</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">EasyFileSystem</span> &#123;</span><br><span class="line">    <span class="comment">///Real device</span></span><br><span class="line">    <span class="keyword">pub</span> block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">    <span class="comment">///Inode bitmap</span></span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap: Bitmap,</span><br><span class="line">    <span class="comment">///Data bitmap</span></span><br><span class="line">    <span class="keyword">pub</span> data_bitmap: Bitmap,</span><br><span class="line">    inode_area_start_block: <span class="type">u32</span>,</span><br><span class="line">    data_area_start_block: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// A bitmap</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Bitmap</span> &#123;</span><br><span class="line">    start_block_id: <span class="type">usize</span>,</span><br><span class="line">    blocks: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是文件系统核心数据结构EasyFileSystem，包含一个实际块设备指针block_device用来真实操作设备，一个bitmap位图表示Inode和Data的分配情况，还有两个u32分别表示Inode和Data的起始块号。<br>这个数据结构存在于内存中，不实际存在于磁盘中，实际磁盘上使用了SuperBlock来表示，并存放在磁盘的0号块中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SuperBlock</span> &#123;</span><br><span class="line">    magic: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> total_blocks: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap_blocks: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> inode_area_blocks: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> data_bitmap_blocks: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> data_area_blocks: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么实际磁盘存储结构可以以下结构表示：<br>| super block | inode_bitmap | inode_area | data_bitmap | data_area |</p>
<h2 id="创建文件镜像"><a href="#创建文件镜像" class="headerlink" title="创建文件镜像"></a>创建文件镜像</h2><p>本章中我们需要使用文件系统来动态加载app，需要创建文件镜像存放app数据。具体代码在easy_fs_pack。<br>首先创建了fs.img，并将其大小设置为16 * 2048 * 512，即16*2048个块</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">block_file</span> = Arc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">BlockFile</span>(Mutex::<span class="title function_ invoke__">new</span>(&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = OpenOptions::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read</span>(<span class="literal">true</span>)</span><br><span class="line">        .<span class="title function_ invoke__">write</span>(<span class="literal">true</span>)</span><br><span class="line">        .<span class="title function_ invoke__">create</span>(<span class="literal">true</span>)</span><br><span class="line">        .<span class="title function_ invoke__">open</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, target_path, <span class="string">&quot;fs.img&quot;</span>))?;</span><br><span class="line">    f.<span class="title function_ invoke__">set_len</span>(<span class="number">16</span> * <span class="number">2048</span> * <span class="number">512</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    f</span><br><span class="line">&#125;)));</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A data block of block size</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">create</span>(</span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">    total_blocks: <span class="type">u32</span>,</span><br><span class="line">    inode_bitmap_blocks: <span class="type">u32</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// calculate block size of areas &amp; create bitmaps</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inode_bitmap</span> = Bitmap::<span class="title function_ invoke__">new</span>(<span class="number">1</span>, inode_bitmap_blocks <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inode_num</span> = inode_bitmap.<span class="title function_ invoke__">maximum</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inode_area_blocks</span> =</span><br><span class="line">        ((inode_num * core::mem::size_of::&lt;DiskInode&gt;() + BLOCK_SZ - <span class="number">1</span>) / BLOCK_SZ) <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inode_total_blocks</span> = inode_bitmap_blocks + inode_area_blocks;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_total_blocks</span> = total_blocks - <span class="number">1</span> - inode_total_blocks;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_bitmap_blocks</span> = (data_total_blocks + <span class="number">4096</span>) / <span class="number">4097</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_area_blocks</span> = data_total_blocks - data_bitmap_blocks;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_bitmap</span> = Bitmap::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        (<span class="number">1</span> + inode_bitmap_blocks + inode_area_blocks) <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">        data_bitmap_blocks <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">efs</span> = <span class="keyword">Self</span> &#123;</span><br><span class="line">        block_device: Arc::<span class="title function_ invoke__">clone</span>(&amp;block_device),</span><br><span class="line">        inode_bitmap,</span><br><span class="line">        data_bitmap,</span><br><span class="line">        inode_area_start_block: <span class="number">1</span> + inode_bitmap_blocks,</span><br><span class="line">        data_area_start_block: <span class="number">1</span> + inode_total_blocks + data_bitmap_blocks,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// clear all blocks</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..total_blocks &#123;</span><br><span class="line">        <span class="title function_ invoke__">get_block_cache</span>(i <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(&amp;block_device))</span><br><span class="line">            .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">modify</span>(<span class="number">0</span>, |data_block: &amp;<span class="keyword">mut</span> DataBlock| &#123;</span><br><span class="line">                <span class="keyword">for</span> <span class="variable">byte</span> <span class="keyword">in</span> data_block.<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">                    *byte = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// initialize SuperBlock</span></span><br><span class="line">    <span class="title function_ invoke__">get_block_cache</span>(<span class="number">0</span>, Arc::<span class="title function_ invoke__">clone</span>(&amp;block_device)).<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">modify</span>(</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        |super_block: &amp;<span class="keyword">mut</span> SuperBlock| &#123;</span><br><span class="line">            super_block.<span class="title function_ invoke__">initialize</span>(</span><br><span class="line">                total_blocks,</span><br><span class="line">                inode_bitmap_blocks,</span><br><span class="line">                inode_area_blocks,</span><br><span class="line">                data_bitmap_blocks,</span><br><span class="line">                data_area_blocks,</span><br><span class="line">            );</span><br><span class="line">        &#125;,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// write back immediately</span></span><br><span class="line">    <span class="comment">// create a inode for root node &quot;/&quot;</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(efs.<span class="title function_ invoke__">alloc_inode</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> (root_inode_block_id, root_inode_offset) = efs.<span class="title function_ invoke__">get_disk_inode_pos</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="title function_ invoke__">get_block_cache</span>(root_inode_block_id <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(&amp;block_device))</span><br><span class="line">        .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">        .<span class="title function_ invoke__">modify</span>(root_inode_offset, |disk_inode: &amp;<span class="keyword">mut</span> DiskInode| &#123;</span><br><span class="line">            disk_inode.<span class="title function_ invoke__">initialize</span>(DiskInodeType::Directory);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="title function_ invoke__">block_cache_sync_all</span>();</span><br><span class="line">    Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(efs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后调用EasyFileSystem::create(block_file, 16 * 2048, 1)来创建文件系统。<br>细细分析下这段代码：</p>
<ul>
<li><p>参数分析：<br>  传入三个参数，block_device: block_file对应我们写入的fs.img镜像，total_blocks: 16*2048表示fs.img镜像块数量，inode_bitmap_blocks：1，表示现在inode块位图占用一个块。</p>
</li>
<li><p>磁盘布局</p>
<ul>
<li>inode_bitmap：从块1开始，占用1块，表示inode块位图。</li>
<li>inode_num：索引数量4096，一共一个块，4096位</li>
<li>inode_area_blocks：4096个DiskNode，DiskNode大小128字节，块512字节，总计1024个</li>
<li>inode_total_blocks：1+1024总共1025个块</li>
<li>data_total_blocks: 除去superblock和inode剩下全是data相关，即16*2048-1-1025&#x3D;31742</li>
<li>data_bitmap_blocks：(31742+4096)&#x2F;4097&#x3D;8，由于一个块的bitmap可以索引4096个数据块，为了最大化使用磁盘，除以4097再向上取整。这里是8，可以索引8*4096&#x3D;32768个数据块，覆盖了上面31742剩余块</li>
<li>data_area_blocks：31742-8&#x3D;31734，即剩余31734个块，用来存放数据。</li>
<li>data_bitmap：从块1+1025开始，占用8块，表示data块位图。</li>
</ul>
<p>  最终磁盘布局如下：<br>  super block: 0<br>  inode_bitmap: 1<br>  inode_area: 2-1025<br>  data_bitmap: 1026-1033<br>  data_area: 1034-31742</p>
</li>
<li><p>初始化数据<br>  由于easy_fs本身很简单，只有一个root目录，之后文件均放在根目录下，所以需要初始根目录，所有操作均通过get_block_cache写入缓存，最终block_cache_sync_all同步到磁盘中。</p>
<ul>
<li>清空所有块，初始化super block</li>
<li>创建根目录：通过alloc_inode分配inode，这是必然为0，再通过get_disk_inode_pos获取inode在哪个块和偏移（因为一个块中有多个DiskNode)，然后写入DiskInode初始化为目录类型</li>
<li>最后block_cache_sync_all同步修改到磁盘中</li>
</ul>
</li>
<li><p>写入app数据<br>  我们的app数据均直接放在root目录下，所以我们需要拿到root_inode，然后创建文件inode，再写入数据</p>
<ul>
<li>通过root_inode拿到root的Inode</li>
<li>遍历所有app，读取app数据，通过Inode::create创建文件inode</li>
<li>通过Inode::write_at写入数据<br>至此我们就完成了fs.img的创建，其中包括了super block用来描述文件系统，创建了root_inode，以及写入了所有app数据。</li>
</ul>
</li>
</ul>
<h2 id="内核中使用文件系统"><a href="#内核中使用文件系统" class="headerlink" title="内核中使用文件系统"></a>内核中使用文件系统</h2><ul>
<li><p>块设备初始化</p>
<ul>
<li>qemu配置了VirtIO 块设备，内存映射 I&#x2F;O (MMIO, Memory-Mapped I&#x2F;O) 指通过特定的物理内存地址来访问外设的设备寄存器。查阅资料，可知 VirtIO 总线的 MMIO 物理地址区间为从 0x10001000 开头的 4KiB。<br>  将这一段物理内存区间直接恒等映射到内核空间。</li>
<li>块设备实例  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/drivers/block/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">BlockDeviceImpl</span> = virtio_blk::VirtIOBlock;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> BLOCK_DEVICE: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt; = Arc::<span class="title function_ invoke__">new</span>(BlockDeviceImpl::<span class="title function_ invoke__">new</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  BLOCK_DEVICE是一个Arc<dyn BlockDevice>，即加载文件系统需要的块设备</li>
</ul>
</li>
<li><p>加载文件系统<br>  我们现在已经有了块设备，可以加载文件系统了。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/fs/inode.rs</span></span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> ROOT_INODE: Arc&lt;Inode&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">efs</span> = EasyFileSystem::<span class="title function_ invoke__">open</span>(BLOCK_DEVICE.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">        Arc::<span class="title function_ invoke__">new</span>(EasyFileSystem::<span class="title function_ invoke__">root_inode</span>(&amp;efs))</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  通过EasyFileSystem::open从BLOCK_DEVICE加载创建EasyFileSystem数据结构到内存中，通过root_inode获取到root_inode，至此我们就可以通过ROOT_INODE访问到文件系统了，就像下面一样。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/fs/inode.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">list_apps</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;/**** APPS ****&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">app</span> <span class="keyword">in</span> ROOT_INODE.<span class="title function_ invoke__">ls</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, app);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;**************/&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  现在回过头分析EasyFileSystem::open</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">open</span>(block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) <span class="punctuation">-&gt;</span> Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// read SuperBlock</span></span><br><span class="line">    <span class="title function_ invoke__">get_block_cache</span>(<span class="number">0</span>, Arc::<span class="title function_ invoke__">clone</span>(&amp;block_device))</span><br><span class="line">        .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read</span>(<span class="number">0</span>, |super_block: &amp;SuperBlock| &#123;</span><br><span class="line">            <span class="built_in">assert!</span>(super_block.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;Error loading EFS!&quot;</span>);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">inode_total_blocks</span> =</span><br><span class="line">                super_block.inode_bitmap_blocks + super_block.inode_area_blocks;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">efs</span> = <span class="keyword">Self</span> &#123;</span><br><span class="line">                block_device,</span><br><span class="line">                inode_bitmap: Bitmap::<span class="title function_ invoke__">new</span>(<span class="number">1</span>, super_block.inode_bitmap_blocks <span class="keyword">as</span> <span class="type">usize</span>),</span><br><span class="line">                data_bitmap: Bitmap::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                    (<span class="number">1</span> + inode_total_blocks) <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">                    super_block.data_bitmap_blocks <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">                ),</span><br><span class="line">                inode_area_start_block: <span class="number">1</span> + super_block.inode_bitmap_blocks,</span><br><span class="line">                data_area_start_block: <span class="number">1</span> + inode_total_blocks + super_block.data_bitmap_blocks,</span><br><span class="line">            &#125;;</span><br><span class="line">            Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(efs))</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  我们知道需要通过SuperBlock来初始化EasyFileSystem，而SuperBlock是放在块0中的，所以我们需要通过get_block_cache来读取块0，然后通过read方法读取块0中的SuperBlock。</p>
</li>
<li><p>使用文件系统</p>
<ul>
<li><p>封装Inode<br>  为了更好使用Inode，将其封装OSInode</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/fs/inode.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">OSInode</span> &#123;</span><br><span class="line">    readable: <span class="type">bool</span>,</span><br><span class="line">    writable: <span class="type">bool</span>,</span><br><span class="line">    inner: UPSafeCell&lt;OSInodeInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">OSInodeInner</span> &#123;</span><br><span class="line">    offset: <span class="type">usize</span>,</span><br><span class="line">    inode: Arc&lt;Inode&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  并为其实现File Trait</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">File</span> <span class="keyword">for</span> <span class="title class_">OSInode</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">readable</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.readable</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">writable</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.writable</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">read</span>(&amp;<span class="keyword">self</span>, <span class="keyword">mut</span> buf: UserBuffer) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total_read_size</span> = <span class="number">0usize</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">slice</span> <span class="keyword">in</span> buf.buffers.<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">read_size</span> = inner.inode.<span class="title function_ invoke__">read_at</span>(inner.offset, *slice);</span><br><span class="line">            <span class="keyword">if</span> read_size == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            inner.offset += read_size;</span><br><span class="line">            total_read_size += read_size;</span><br><span class="line">        &#125;</span><br><span class="line">        total_read_size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>, <span class="keyword">mut</span> buf: UserBuffer) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total_write_size</span> = <span class="number">0usize</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">slice</span> <span class="keyword">in</span> buf.buffers.<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">write_size</span> = inner.inode.<span class="title function_ invoke__">write_at</span>(inner.offset, *slice);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(write_size, slice.<span class="title function_ invoke__">len</span>());</span><br><span class="line">            inner.offset += write_size;</span><br><span class="line">            total_write_size += write_size;</span><br><span class="line">        &#125;</span><br><span class="line">        total_write_size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fstat</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Stat &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">        inner.inode.<span class="title function_ invoke__">get_block_id</span>()</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">inode_id</span>;</span><br><span class="line">        Stat &#123;</span><br><span class="line">            dev: <span class="number">0</span>,</span><br><span class="line">            ino: inode_id,</span><br><span class="line">            mode: (),</span><br><span class="line">            nlink: (),</span><br><span class="line">            pad: (),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  read和write的实现也比较简单，拿到OSInodeInner，然后调用Inode的read_at和write_at方法即可。</p>
</li>
<li><p>操作文件系统<br>  对文件系统操作有很多比如打开文件，创建文件等，主要都通过Inode提供对应方法来操作。以下以打开文件为例：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">open_file</span>(name: &amp;<span class="type">str</span>, flags: OpenFlags) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;OSInode&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> (readable, writable) = flags.<span class="title function_ invoke__">read_write</span>();</span><br><span class="line">    <span class="keyword">if</span> flags.<span class="title function_ invoke__">contains</span>(OpenFlags::CREATE) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(inode) = ROOT_INODE.<span class="title function_ invoke__">find</span>(name) &#123;</span><br><span class="line">            <span class="comment">// clear size</span></span><br><span class="line">            inode.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(OSInode::<span class="title function_ invoke__">new</span>(readable, writable, inode)))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// create file</span></span><br><span class="line">            ROOT_INODE</span><br><span class="line">                .<span class="title function_ invoke__">create</span>(name)</span><br><span class="line">                .<span class="title function_ invoke__">map</span>(|inode| Arc::<span class="title function_ invoke__">new</span>(OSInode::<span class="title function_ invoke__">new</span>(readable, writable, inode)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ROOT_INODE.<span class="title function_ invoke__">find</span>(name).<span class="title function_ invoke__">map</span>(|inode| &#123;</span><br><span class="line">            <span class="keyword">if</span> flags.<span class="title function_ invoke__">contains</span>(OpenFlags::TRUNC) &#123;</span><br><span class="line">                inode.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            Arc::<span class="title function_ invoke__">new</span>(OSInode::<span class="title function_ invoke__">new</span>(readable, writable, inode))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  通过Inode::find找对应文件，Inode::create创建文件。</p>
</li>
</ul>
</li>
</ul>
<h1 id="内部实现方向"><a href="#内部实现方向" class="headerlink" title="内部实现方向"></a>内部实现方向</h1><p>这里我先换个方法，从最底层开始思考，看看是如何实现文件系统的。</p>
<h2 id="文件在磁盘上的形式"><a href="#文件在磁盘上的形式" class="headerlink" title="文件在磁盘上的形式"></a>文件在磁盘上的形式</h2><p>文件系统API部分我们知道整个文件系统分成5部分<br>| super block | inode_bitmap | inode_area | data_bitmap | data_area |<br>也应该明白，文件中的数据是放在data_area中的，为了标记数据是属于哪个文件的，我们就需要索引DiskInode。</p>
<h3 id="DiskInode"><a href="#DiskInode" class="headerlink" title="DiskInode"></a>DiskInode</h3><ol>
<li><p>定义</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">DiskInode</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> size: <span class="type">u32</span>,                          <span class="comment">// 文件大小</span></span><br><span class="line">    <span class="keyword">pub</span> direct: [<span class="type">u32</span>; INODE_DIRECT_COUNT],  <span class="comment">// 直接索引</span></span><br><span class="line">    <span class="keyword">pub</span> indirect1: <span class="type">u32</span>,                     <span class="comment">// 一级索引</span></span><br><span class="line">    <span class="keyword">pub</span> indirect2: <span class="type">u32</span>,                     <span class="comment">// 二级索引</span></span><br><span class="line">    type_: DiskInodeType,                   <span class="comment">// 文件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当 size&lt;&#x3D;14KB时，直接索引，此时DiskInode对应的data_area全是文件数据，内部块ID[0,28)<br> 当 14KB&lt; size &lt; 78KB时，使用了一级索引，此时data_area中会增加一个块来存储一级索引，内部块ID[28, 28 + 128)<br> 当 size &gt; 78KB时，使用了二级索引，此时data_area会在上面的基础上，再增加一块二级索引块，之后根据二级索引块中使用情况增加对等一级索引块，内部块ID[156, 156 + 128*128)</p>
<p> 所有的DiskInode依次放在inode_area中。<br> 对于文件来说，data_area存放文件数据，即DataBlock</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">DataBlock</span> = [<span class="type">u8</span>; BLOCK_SZ];</span><br></pre></td></tr></table></figure>
<p> 对于目录来说，没有文件数据，但是我们需要记录目录下的文件，所有我们就有了DirEntry</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A directory entry</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">DirEntry</span> &#123;</span><br><span class="line">    name: [<span class="type">u8</span>; NAME_LENGTH_LIMIT + <span class="number">1</span>],</span><br><span class="line">    inode_id: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 一个name用来存储文件名，一个inode_id用来存储文件的inode_id。<br> 一个目录下可能有多个文件，每个文件对应一个目录项，一次存放在目录的data_area中。</p>
</li>
<li><p>创建DiskInode</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">new_inode_id</span> = fs.<span class="title function_ invoke__">alloc_inode</span>();</span><br><span class="line"><span class="comment">// initialize inode</span></span><br><span class="line"><span class="keyword">let</span> (new_inode_block_id, new_inode_block_offset) = fs.<span class="title function_ invoke__">get_disk_inode_pos</span>(new_inode_id);</span><br><span class="line"><span class="title function_ invoke__">get_block_cache</span>(new_inode_block_id <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(&amp;<span class="keyword">self</span>.block_device))</span><br><span class="line">    .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">    .<span class="title function_ invoke__">modify</span>(new_inode_block_offset, |new_inode: &amp;<span class="keyword">mut</span> DiskInode| &#123;</span><br><span class="line">        new_inode.<span class="title function_ invoke__">initialize</span>(DiskInodeType::File);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>分配一个inode_id，通过Bitmap::alloc</li>
<li>通过inode_id找到inode_area中的block_id和offset</li>
<li>将DiskInode写入block_id中的offset位置</li>
</ul>
</li>
<li><p>文件扩容</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">increase_size</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    new_size: <span class="type">u32</span>,</span><br><span class="line">    new_blocks: <span class="type">Vec</span>&lt;<span class="type">u32</span>&gt;,</span><br><span class="line">    block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">current_blocks</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">data_blocks</span>();</span><br><span class="line">    <span class="keyword">self</span>.size = new_size;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total_blocks</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">data_blocks</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">new_blocks</span> = new_blocks.<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line">    <span class="comment">// fill direct</span></span><br><span class="line">    <span class="keyword">while</span> current_blocks &lt; total_blocks.<span class="title function_ invoke__">min</span>(INODE_DIRECT_COUNT <span class="keyword">as</span> <span class="type">u32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.direct[current_blocks <span class="keyword">as</span> <span class="type">usize</span>] = new_blocks.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        current_blocks += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// alloc indirect1</span></span><br><span class="line">    <span class="keyword">if</span> total_blocks &gt; INODE_DIRECT_COUNT <span class="keyword">as</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current_blocks == INODE_DIRECT_COUNT <span class="keyword">as</span> <span class="type">u32</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.indirect1 = new_blocks.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        current_blocks -= INODE_DIRECT_COUNT <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line">        total_blocks -= INODE_DIRECT_COUNT <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fill indirect1</span></span><br><span class="line">    <span class="title function_ invoke__">get_block_cache</span>(<span class="keyword">self</span>.indirect1 <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(block_device))</span><br><span class="line">        .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">        .<span class="title function_ invoke__">modify</span>(<span class="number">0</span>, |indirect1: &amp;<span class="keyword">mut</span> IndirectBlock| &#123;</span><br><span class="line">            <span class="keyword">while</span> current_blocks &lt; total_blocks.<span class="title function_ invoke__">min</span>(INODE_INDIRECT1_COUNT <span class="keyword">as</span> <span class="type">u32</span>) &#123;</span><br><span class="line">                indirect1[current_blocks <span class="keyword">as</span> <span class="type">usize</span>] = new_blocks.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                current_blocks += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">// alloc indirect2</span></span><br><span class="line">    <span class="keyword">if</span> total_blocks &gt; INODE_INDIRECT1_COUNT <span class="keyword">as</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current_blocks == INODE_INDIRECT1_COUNT <span class="keyword">as</span> <span class="type">u32</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.indirect2 = new_blocks.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        current_blocks -= INODE_INDIRECT1_COUNT <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line">        total_blocks -= INODE_INDIRECT1_COUNT <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fill indirect2 from (a0, b0) -&gt; (a1, b1)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a0</span> = current_blocks <span class="keyword">as</span> <span class="type">usize</span> / INODE_INDIRECT1_COUNT;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b0</span> = current_blocks <span class="keyword">as</span> <span class="type">usize</span> % INODE_INDIRECT1_COUNT;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a1</span> = total_blocks <span class="keyword">as</span> <span class="type">usize</span> / INODE_INDIRECT1_COUNT;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b1</span> = total_blocks <span class="keyword">as</span> <span class="type">usize</span> % INODE_INDIRECT1_COUNT;</span><br><span class="line">    <span class="comment">// alloc low-level indirect1</span></span><br><span class="line">    <span class="title function_ invoke__">get_block_cache</span>(<span class="keyword">self</span>.indirect2 <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(block_device))</span><br><span class="line">        .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">        .<span class="title function_ invoke__">modify</span>(<span class="number">0</span>, |indirect2: &amp;<span class="keyword">mut</span> IndirectBlock| &#123;</span><br><span class="line">            <span class="keyword">while</span> (a0 &lt; a1) || (a0 == a1 &amp;&amp; b0 &lt; b1) &#123;</span><br><span class="line">                <span class="keyword">if</span> b0 == <span class="number">0</span> &#123;</span><br><span class="line">                    indirect2[a0] = new_blocks.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fill current</span></span><br><span class="line">                <span class="title function_ invoke__">get_block_cache</span>(indirect2[a0] <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(block_device))</span><br><span class="line">                    .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">                    .<span class="title function_ invoke__">modify</span>(<span class="number">0</span>, |indirect1: &amp;<span class="keyword">mut</span> IndirectBlock| &#123;</span><br><span class="line">                        indirect1[b0] = new_blocks.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                    &#125;);</span><br><span class="line">                <span class="comment">// move to next</span></span><br><span class="line">                b0 += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> b0 == INODE_INDIRECT1_COUNT &#123;</span><br><span class="line">                    b0 = <span class="number">0</span>;</span><br><span class="line">                    a0 += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 传入参数new_size为新文件大小，new_blocks为新分配的data_area中的块ID。<br> 这里假设我们之前文件大小为20个块，现在扩容到256个块（1个一级索引块，1个二级索引块，1个二级索引对应的1级索引块）</p>
<ul>
<li>最开始current_blocks为20，total_blocks为256，new_blocks[0;236)</li>
<li>填充直接索引，current_blocks为28，total_blocks为256，new_blocks[8,236)</li>
<li>填充一级索引，indirect1 &#x3D; 8, current_blocks置0，total_bloocks为256-28&#x3D;228，new_blocks[9,236)</li>
<li>填充一级索引块，不断从new_blocks中取出block_id写入索引块中，current_blocks为128，total_bloocks为228，new_blocks[137,236)</li>
<li>填充二级索引，indirect2 &#x3D; 137，current_blocks置0，total_blocks为228-128&#x3D;100，new_blocks[138,236)</li>
<li>填充二级索引块，从(0,0)到(0,100)，也是不断从new_blocks取出block_id，当开启新的一级索引块时，填充以下二级索引块，其他情况填充1级索引块</li>
</ul>
<p> 最终可以发现DiskInode在磁盘上布局<br> | file_data_0-27 | indirect1_0 | file_data_28_155 |indirect2 | indirect1_1 | file_data_156_283 |</p>
</li>
<li><p>访问文件数据<br> 我们有了DiskInode，现在需要访问文件数据的能力。<br> DiskInode的data_area流中，存在索引页，假设数据的内部下表[0,n)，<br> 我们需要一个函数，快捷返回对应block_id即get_block_id</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_block_id</span>(&amp;<span class="keyword">self</span>, inner_id: <span class="type">u32</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inner_id</span> = inner_id <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">if</span> inner_id &lt; INODE_DIRECT_COUNT &#123;</span><br><span class="line">        <span class="keyword">self</span>.direct[inner_id]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> inner_id &lt; INDIRECT1_BOUND &#123;</span><br><span class="line">        <span class="title function_ invoke__">get_block_cache</span>(<span class="keyword">self</span>.indirect1 <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(block_device))</span><br><span class="line">            .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">read</span>(<span class="number">0</span>, |indirect_block: &amp;IndirectBlock| &#123;</span><br><span class="line">                indirect_block[inner_id - INODE_DIRECT_COUNT]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">last</span> = inner_id - INDIRECT1_BOUND;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">indirect1</span> = <span class="title function_ invoke__">get_block_cache</span>(<span class="keyword">self</span>.indirect2 <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(block_device))</span><br><span class="line">            .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">read</span>(<span class="number">0</span>, |indirect2: &amp;IndirectBlock| &#123;</span><br><span class="line">                indirect2[last / INODE_INDIRECT1_COUNT]</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="title function_ invoke__">get_block_cache</span>(indirect1 <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(block_device))</span><br><span class="line">            .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">read</span>(<span class="number">0</span>, |indirect1: &amp;IndirectBlock| &#123;</span><br><span class="line">                indirect1[last % INODE_INDIRECT1_COUNT]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 流程如下：<br> - 如果inner_id小于direct，直接返回direct[inner_id]<br> - 如果inner_id处于一级索引中，读取indirect1中一级索引页的内容indreict_block，那么block_id即indirect_block[inner_id-28]<br> - 如果inner_id处于二级索引中，将inner_id减去156为last<br> 读取indirect2中的二级索引页，目标block_id即(last &#x2F; 128, last % 128)处<br> 那么访问文件数据如下，以读文件为例：</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">read_at</span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    offset: <span class="type">usize</span>,</span><br><span class="line">    buf: &amp;<span class="keyword">mut</span> [<span class="type">u8</span>],</span><br><span class="line">    block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">start</span> = offset;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">end</span> = (offset + buf.<span class="title function_ invoke__">len</span>()).<span class="title function_ invoke__">min</span>(<span class="keyword">self</span>.size <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">start_block</span> = start / BLOCK_SZ;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">read_size</span> = <span class="number">0usize</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// calculate end of current block</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">end_current_block</span> = (start / BLOCK_SZ + <span class="number">1</span>) * BLOCK_SZ;</span><br><span class="line">        end_current_block = end_current_block.<span class="title function_ invoke__">min</span>(end);</span><br><span class="line">        <span class="comment">// read and update read size</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">block_read_size</span> = end_current_block - start;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">dst</span> = &amp;<span class="keyword">mut</span> buf[read_size..read_size + block_read_size];</span><br><span class="line">        <span class="title function_ invoke__">get_block_cache</span>(</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">get_block_id</span>(start_block <span class="keyword">as</span> <span class="type">u32</span>, block_device) <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">            Arc::<span class="title function_ invoke__">clone</span>(block_device),</span><br><span class="line">        )</span><br><span class="line">        .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read</span>(<span class="number">0</span>, |data_block: &amp;DataBlock| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">src</span> = &amp;data_block[start % BLOCK_SZ..start % BLOCK_SZ + block_read_size];</span><br><span class="line">            dst.<span class="title function_ invoke__">copy_from_slice</span>(src);</span><br><span class="line">        &#125;);</span><br><span class="line">        read_size += block_read_size;</span><br><span class="line">        <span class="comment">// move to next block</span></span><br><span class="line">        <span class="keyword">if</span> end_current_block == end &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start_block += <span class="number">1</span>;</span><br><span class="line">        start = end_current_block;</span><br><span class="line">    &#125;</span><br><span class="line">    read_size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 参数分析：<br> offset：相对于DiskInode的偏移量<br> buf：缓冲区，存放读取数据，读取最多buf.len()个字节<br> block_device：块设备，用来访问文件数据<br> 返回值：读取的字节数<br> offset基本可以与外部统一为文件的偏移量，<br> 先根据文件大小与缓冲区长度确定读取范围，即读取[offset,end)<br> 然后从offset&#x2F;BLOCK_SZ start_block开始<br> 通过get_block_id()拿到start_block的真正block_id，<br> 然后读取对应DataBlock，通过copy_from_slice到buf<br> 然后start_block+1，读取下块<br> 这个通过一个块一个块读取，跳过了对应的索引页</p>
</li>
</ol>
<h2 id="外部世界与文件桥梁"><a href="#外部世界与文件桥梁" class="headerlink" title="外部世界与文件桥梁"></a>外部世界与文件桥梁</h2><p>之前我们以API的角度来分析了Inode，现在我们以文件系统内部视角来分析Inode。<br>Inode处于文件系统API层，用来封装DiskInode，提供更方便的访问文件数据的能力。</p>
<ol>
<li><p>定义</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Inode</span> &#123;</span><br><span class="line">    block_id: <span class="type">usize</span>,</span><br><span class="line">    block_offset: <span class="type">usize</span>,</span><br><span class="line">    fs: Arc&lt;Mutex&lt;EasyFileSystem&gt;&gt;,</span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Inode是一个DiskInode的封装，如何索引DiskInode，通过块ID加上块内offset即可索引到对应DiskInode。<br> 为了方便通过block_id，block_offset操作DiskInode，增加两个内部方法</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Call a function over a disk inode to read it</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_disk_inode</span>&lt;V&gt;(&amp;<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="title class_">FnOnce</span>(&amp;DiskInode) <span class="punctuation">-&gt;</span> V) <span class="punctuation">-&gt;</span> V &#123;</span><br><span class="line">    <span class="title function_ invoke__">get_block_cache</span>(<span class="keyword">self</span>.block_id, Arc::<span class="title function_ invoke__">clone</span>(&amp;<span class="keyword">self</span>.block_device))</span><br><span class="line">        .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read</span>(<span class="keyword">self</span>.block_offset, f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Call a function over a disk inode to modify it</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">modify_disk_inode</span>&lt;V&gt;(&amp;<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="title class_">FnOnce</span>(&amp;<span class="keyword">mut</span> DiskInode) <span class="punctuation">-&gt;</span> V) <span class="punctuation">-&gt;</span> V &#123;</span><br><span class="line">    <span class="title function_ invoke__">get_block_cache</span>(<span class="keyword">self</span>.block_id, Arc::<span class="title function_ invoke__">clone</span>(&amp;<span class="keyword">self</span>.block_device))</span><br><span class="line">        .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">        .<span class="title function_ invoke__">modify</span>(<span class="keyword">self</span>.block_offset, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Inode</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Create inode under current inode by name</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">create</span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;Inode&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fs</span> = <span class="keyword">self</span>.fs.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">op</span> = |root_inode: &amp;DiskInode| &#123;</span><br><span class="line">        <span class="comment">// assert it is a directory</span></span><br><span class="line">        <span class="built_in">assert!</span>(root_inode.<span class="title function_ invoke__">is_dir</span>());</span><br><span class="line">        <span class="comment">// has the file been created?</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">find_inode_id</span>(name, root_inode)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">read_disk_inode</span>(op).<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// create a new file</span></span><br><span class="line">    <span class="comment">// alloc a inode with an indirect block</span></span><br><span class="line">    <span class="comment">/// 创建DiskInode</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_inode_id</span> = fs.<span class="title function_ invoke__">alloc_inode</span>();</span><br><span class="line">    <span class="comment">// initialize inode</span></span><br><span class="line">    <span class="keyword">let</span> (new_inode_block_id, new_inode_block_offset) = fs.<span class="title function_ invoke__">get_disk_inode_pos</span>(new_inode_id);</span><br><span class="line">    <span class="title function_ invoke__">get_block_cache</span>(new_inode_block_id <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(&amp;<span class="keyword">self</span>.block_device))</span><br><span class="line">        .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">        .<span class="title function_ invoke__">modify</span>(new_inode_block_offset, |new_inode: &amp;<span class="keyword">mut</span> DiskInode| &#123;</span><br><span class="line">            new_inode.<span class="title function_ invoke__">initialize</span>(DiskInodeType::File);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 增加目录项</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">modify_disk_inode</span>(|root_inode| &#123;</span><br><span class="line">        <span class="comment">// append file in the dirent</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">file_count</span> = (root_inode.size <span class="keyword">as</span> <span class="type">usize</span>) / DIRENT_SZ;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">new_size</span> = (file_count + <span class="number">1</span>) * DIRENT_SZ;</span><br><span class="line">        <span class="comment">// increase size</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">increase_size</span>(new_size <span class="keyword">as</span> <span class="type">u32</span>, root_inode, &amp;<span class="keyword">mut</span> fs);</span><br><span class="line">        <span class="comment">// write dirent</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">dirent</span> = DirEntry::<span class="title function_ invoke__">new</span>(name, new_inode_id);</span><br><span class="line">        root_inode.<span class="title function_ invoke__">write_at</span>(</span><br><span class="line">            file_count * DIRENT_SZ,</span><br><span class="line">            dirent.<span class="title function_ invoke__">as_bytes</span>(),</span><br><span class="line">            &amp;<span class="keyword">self</span>.block_device,</span><br><span class="line">        );</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (block_id, block_offset) = fs.<span class="title function_ invoke__">get_disk_inode_pos</span>(new_inode_id);</span><br><span class="line">    <span class="title function_ invoke__">block_cache_sync_all</span>();</span><br><span class="line">    <span class="comment">// return inode</span></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(<span class="keyword">Self</span>::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        block_id,</span><br><span class="line">        block_offset,</span><br><span class="line">        <span class="keyword">self</span>.fs.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        <span class="keyword">self</span>.block_device.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    )))</span><br><span class="line">    <span class="comment">// release efs lock automatically by compiler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 参数分析：</p>
<ul>
<li>name：文件名</li>
<li>返回值：创建的文件的Inode<br> 首先检查是否目录，是否已有相同名称文件。<br> 接着创建DiskInode<br> 通过modify_disk_inode写入目录项，写入时要先扩容DiskInode，在写入目录项<br> block_cache_sync_all同步块缓存，返回Inode</li>
</ul>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://rubick-hqm.github.io/2025/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" data-id="cm9wpll4p00038wvj2nav8jme" data-title="操作系统_文件系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          操作系统_总结
        
      </div>
    </a>
  
  
    <a href="/2025/04/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">操作系统_进程及进程管理</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统_总结</a>
          </li>
        
          <li>
            <a href="/2025/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">操作系统_文件系统</a>
          </li>
        
          <li>
            <a href="/2025/04/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">操作系统_进程及进程管理</a>
          </li>
        
          <li>
            <a href="/2025/03/02/serde/">serde的使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>