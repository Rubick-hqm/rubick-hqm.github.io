<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://rubick-hqm.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://rubick-hqm.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-操作系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2025-04-24T07:46:21.874Z" itemprop="datePublished">2025-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统_总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>以下是参加清华大学2025 春夏季开源操作系统训练营学习blog。<br>本节关于操作系统的文件系统相关的内容。</p>
<h2 id="运行内核"><a href="#运行内核" class="headerlink" title="运行内核"></a>运行内核</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">KERNEL_ENTRY_PA := 0x80200000</span><br><span class="line">@qemu-system-riscv64 \</span><br><span class="line">    -M 128m \</span><br><span class="line">    -machine virt \</span><br><span class="line">    -nographic \</span><br><span class="line">    -bios $(BOOTLOADER) \</span><br><span class="line">    -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) \</span><br><span class="line">    -drive file=$(FS_IMG),if=none,format=raw,id=x0 \</span><br><span class="line">    -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br></pre></td></tr></table></figure>
<p>根据启动命令，通过bios引导加载内核到物理地址是0x80200000。<br>根据连接脚本可知内核的分布如下图所示：<br><img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/kernel_layout.drawio.svg" alt="内核布局图"></p>
<p>从入口_start开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    .section .text.entry</span><br><span class="line">    .globl _start</span><br><span class="line">_start:</span><br><span class="line">    la sp, boot_stack_top</span><br><span class="line">    call rust_main</span><br><span class="line"></span><br><span class="line">    .section .bss.stack</span><br><span class="line">    .globl boot_stack_lower_bound</span><br><span class="line">boot_stack_lower_bound:</span><br><span class="line">    .space 4096 * 16</span><br><span class="line">    .globl boot_stack_top</span><br><span class="line">boot_stack_top:</span><br></pre></td></tr></table></figure>
<p>我们看到将sp设置到了栈顶位置，栈的大小为16KB。之后就到了rust世界rust_main</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;[kernel] Hello, world!&quot;</span>);</span><br><span class="line">    logging::<span class="title function_ invoke__">init</span>();</span><br><span class="line">    mm::<span class="title function_ invoke__">init</span>();</span><br><span class="line">    mm::<span class="title function_ invoke__">remap_test</span>();</span><br><span class="line">    trap::<span class="title function_ invoke__">init</span>();</span><br><span class="line">    trap::<span class="title function_ invoke__">enable_timer_interrupt</span>();</span><br><span class="line">    timer::<span class="title function_ invoke__">set_next_trigger</span>();</span><br><span class="line">    fs::<span class="title function_ invoke__">list_apps</span>();</span><br><span class="line">    task::<span class="title function_ invoke__">add_initproc</span>();</span><br><span class="line">    task::<span class="title function_ invoke__">run_tasks</span>();</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Unreachable in rust_main!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>rust_main中先调用了clear_bss函数，清空.bss段数据，然后初始化日志系统，接着就到了内存管理部分。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>() &#123;</span><br><span class="line">    heap_allocator::<span class="title function_ invoke__">init_heap</span>();</span><br><span class="line">    frame_allocator::<span class="title function_ invoke__">init_frame_allocator</span>();</span><br><span class="line">    KERNEL_SPACE.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">activate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先是两个分配器初始化，一个是堆分配器，一个是物理页分配器。</p>
<h3 id="堆分配器"><a href="#堆分配器" class="headerlink" title="堆分配器"></a>堆分配器</h3><p>为了能在内核中使用Vec等容器，就引入了堆分配器。堆分配器使用的内存在内核的.data段中，大小为32MB</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> HEAP_SPACE: [<span class="type">u8</span>; KERNEL_HEAP_SIZE] = [<span class="number">0</span>; KERNEL_HEAP_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init_heap</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        HEAP_ALLOCATOR</span><br><span class="line">            .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">init</span>(HEAP_SPACE.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, KERNEL_HEAP_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="物理页分配器"><a href="#物理页分配器" class="headerlink" title="物理页分配器"></a>物理页分配器</h3><p>启动qemu时，我们使用了<code>-M 128M</code>，能够支配的物理内存为128M，但是要除去内核大小<br>所以我们能支配的可用物理内存地址为ekernel开始到0x88000000结束。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init_frame_allocator</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ekernel</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    FRAME_ALLOCATOR.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">init</span>(</span><br><span class="line">        PhysAddr::<span class="title function_ invoke__">from</span>(ekernel <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">ceil</span>(),</span><br><span class="line">        PhysAddr::<span class="title function_ invoke__">from</span>(MEMORY_END).<span class="title function_ invoke__">floor</span>(),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    current: <span class="type">usize</span>,</span><br><span class="line">    end: <span class="type">usize</span>,</span><br><span class="line">    recycled: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">alloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PhysPageNum&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">dealloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, ppn: PhysPageNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过StackFrameAllocator来管理物理页，管理的物理页为[current, end)。<br>当申请新物理页时，先从recycled中获取，如果recycled为空，则current+1，使用新的物理页。<br>回收时，将其加入recycled中。<br>我们引入RAII机制，使用FrameTracker来表示一个物理页，当FrameTracker离开作用域时，会自动回收物理页。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="comment">/// physical page number</span></span><br><span class="line">    <span class="keyword">pub</span> ppn: PhysPageNum,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="comment">/// Create a new FrameTracker</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(ppn: PhysPageNum) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// page cleaning</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">bytes_array</span> = ppn.<span class="title function_ invoke__">get_bytes_array</span>();</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> bytes_array &#123;</span><br><span class="line">            *i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ppn &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">frame_dealloc</span>(<span class="keyword">self</span>.ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个物理页分配器提供两个API供外部调用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">frame_alloc</span>() <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;FrameTracker&gt; &#123;</span><br><span class="line">    FRAME_ALLOCATOR</span><br><span class="line">        .<span class="title function_ invoke__">exclusive_access</span>()</span><br><span class="line">        .<span class="title function_ invoke__">alloc</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(FrameTracker::new)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Deallocate a physical page frame with a given ppn</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">frame_dealloc</span>(ppn: PhysPageNum) &#123;</span><br><span class="line">    FRAME_ALLOCATOR.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">dealloc</span>(ppn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内核地址空间"><a href="#内核地址空间" class="headerlink" title="内核地址空间"></a>内核地址空间</h3><p>有了堆分配器，以及物理页分配器之后，我们就能愉快的引入虚拟内存概念，以及创建内核地址空间了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="comment">/// The kernel&#x27;s initial memory mapping(kernel address space)</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> KERNEL_SPACE: Arc&lt;UPSafeCell&lt;MemorySet&gt;&gt; =</span><br><span class="line">        Arc::<span class="title function_ invoke__">new</span>(<span class="keyword">unsafe</span> &#123; UPSafeCell::<span class="title function_ invoke__">new</span>(MemorySet::<span class="title function_ invoke__">new_kernel</span>()) &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>KERNEL_SPACE是一个指针存放在.bss，实际的内核地址空间数据结构MemorySet存放在堆空间.data中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    <span class="comment">/// page table</span></span><br><span class="line">    <span class="keyword">pub</span> page_table: PageTable,</span><br><span class="line">    <span class="comment">/// areas</span></span><br><span class="line">    <span class="keyword">pub</span> areas: <span class="type">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一共2个字段，page_table页表， areas逻辑段。<br>页表用来进行虚拟地址与物理地址的映射，逻辑段即数据内容比如内核的.text,.data段等。<br>内核地址空间包括的物理页即page_table中的物理页和areas中的物理页。</p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>这里使用SV39多级页表</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    root_ppn: PhysPageNum,</span><br><span class="line">    frames: <span class="type">Vec</span>&lt;FrameTracker&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>root_ppn是二级页表，frames是物理页的集合。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    PageTable &#123;</span><br><span class="line">        root_ppn: frame.ppn,</span><br><span class="line">        frames: <span class="built_in">vec!</span>[frame],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页表创建时，首先分配一个物理页作为一级页表，由frames管理，</p>
<p>API如下：</p>
<ul>
<li>map&#x2F;unmap基础功能是虚拟页与物理页的映射  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_pte_create</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">for</span> (i, idx) <span class="keyword">in</span> idxs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[*idx];</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">            result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(frame.ppn, PTEFlags::V);</span><br><span class="line">            <span class="keyword">self</span>.frames.<span class="title function_ invoke__">push</span>(frame);</span><br><span class="line">        &#125;</span><br><span class="line">        ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte_create</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(!pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is mapped before mapping&quot;</span>, vpn);</span><br><span class="line">    *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(ppn, flags | PTEFlags::V);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is invalid before unmapping&quot;</span>, vpn);</span><br><span class="line">    *pte = PageTableEntry::<span class="title function_ invoke__">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  map即API，先通过find_pte_create找到vpn对应页表项，将ppn映射到该页表项。并将标记设置位valid<br>  find_ptr_create逻辑如下：<br>  先根据虚拟页号得到页表的索引，虚拟页号一共27位，均分成3段，每段9位，所以页表包含512个页表项<br>  |25位未用|9位vpn[2]|9位vpn[1]|9位vpn[0]|12位页内偏移|<br>  先通过root_ppn的L2索引找到一级页表，再根据二级索引找到二级页表，再根据三级索引找到对应页表项<br>  刚开始只有L2页表即根页表，先根据L2索引vpn[2]在根页表的物理页中找到页表项，<br>  如果不存在页表项，就创建下一级页表，并将页表项指向该页表，然后逐级创建页表，填写页表项，<br>  到vpn[0]得到最终的物理页的页表项。</li>
<li>translate_va翻译虚拟地址为物理地址<br>  <img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/sv39-va-pa.png" alt="虚拟地址和物理地址转换">  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">translate_va</span>(&amp;<span class="keyword">self</span>, va: VirtAddr) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PhysAddr&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte</span>(va.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">floor</span>()).<span class="title function_ invoke__">map</span>(|pte| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">aligned_pa</span>: PhysAddr = pte.<span class="title function_ invoke__">ppn</span>().<span class="title function_ invoke__">into</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">offset</span> = va.<span class="title function_ invoke__">page_offset</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">aligned_pa_usize</span>: <span class="type">usize</span> = aligned_pa.<span class="title function_ invoke__">into</span>();</span><br><span class="line">        (aligned_pa_usize + offset).<span class="title function_ invoke__">into</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  先找到va的页表项，将页表项中的物理页地址加上页内偏移得到物理地址。</li>
</ul>
<h4 id="逻辑段"><a href="#逻辑段" class="headerlink" title="逻辑段"></a>逻辑段</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MapArea</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> vpn_range: VPNRange,</span><br><span class="line">    <span class="keyword">pub</span> data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;,</span><br><span class="line">    <span class="keyword">pub</span> map_type: MapType,</span><br><span class="line">    <span class="keyword">pub</span> map_perm: MapPermission,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MapArea用来描述逻辑段，包括页表项范围，页帧集合，页类型，页权限。</p>
<p>API如下：</p>
<ul>
<li>new，创建  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(</span><br><span class="line">    start_va: VirtAddr,</span><br><span class="line">    end_va: VirtAddr,</span><br><span class="line">    map_type: MapType,</span><br><span class="line">    map_perm: MapPermission,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">start_vpn</span>: VirtPageNum = start_va.<span class="title function_ invoke__">floor</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">end_vpn</span>: VirtPageNum = end_va.<span class="title function_ invoke__">ceil</span>();</span><br><span class="line">    <span class="keyword">Self</span> &#123;</span><br><span class="line">        vpn_range: VPNRange::<span class="title function_ invoke__">new</span>(start_vpn, end_vpn),</span><br><span class="line">        data_frames: BTreeMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        map_type,</span><br><span class="line">        map_perm,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  给定一段虚拟地址[start_va,end_va)，以map_type映射方式包括恒等映射以及分配物理帧两种映射方式<br>  再包括这一段逻辑的权限包括读，写，执行，以及是否用户可访问。</li>
<li>map&#x2F;unmap，映射  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ppn</span>: PhysPageNum;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.map_type &#123;</span><br><span class="line">        MapType::Identical =&gt; &#123;</span><br><span class="line">            ppn = <span class="title function_ invoke__">PhysPageNum</span>(vpn.<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MapType::Framed =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            ppn = frame.ppn;</span><br><span class="line">            <span class="keyword">self</span>.data_frames.<span class="title function_ invoke__">insert</span>(vpn, frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pte_flags</span> = PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.map_perm.bits).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    page_table.<span class="title function_ invoke__">map</span>(vpn, ppn, pte_flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">vpn</span> <span class="keyword">in</span> <span class="keyword">self</span>.vpn_range &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">map_one</span>(page_table, vpn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  将这段虚拟页以map_type的方式射映射到物理页中。<br>  恒等映射：即物理地址&#x3D;虚拟地址<br>  分配物理帧：通过frame_alloc分配一页物理页，通过page_table.map写到页表中。</li>
</ul>
<h4 id="创建内核地址空间"><a href="#创建内核地址空间" class="headerlink" title="创建内核地址空间"></a>创建内核地址空间</h4><p>回过头来看以下内核的地址空间初始化MemorySet::new_kernel()</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_kernel</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">memory_set</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new_bare</span>();</span><br><span class="line">    <span class="comment">// map trampoline</span></span><br><span class="line">    memory_set.<span class="title function_ invoke__">map_trampoline</span>();</span><br><span class="line">    <span class="comment">// map kernel sections</span></span><br><span class="line">    info!(<span class="string">&quot;.text [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, stext <span class="keyword">as</span> <span class="type">usize</span>, etext <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    info!(<span class="string">&quot;.rodata [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, srodata <span class="keyword">as</span> <span class="type">usize</span>, erodata <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    info!(<span class="string">&quot;.data [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, sdata <span class="keyword">as</span> <span class="type">usize</span>, edata <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    info!(</span><br><span class="line">        <span class="string">&quot;.bss [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,</span><br><span class="line">        sbss_with_stack <span class="keyword">as</span> <span class="type">usize</span>, ebss <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping .text section&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (stext <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (etext <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::X,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping .rodata section&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (srodata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (erodata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping .data section&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (sdata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (edata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::W,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping .bss section&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (sbss_with_stack <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (ebss <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::W,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping physical memory&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (ekernel <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MEMORY_END.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::W,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping memory-mapped registers&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">pair</span> <span class="keyword">in</span> MMIO &#123;</span><br><span class="line">        memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">            MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                (*pair).<span class="number">0</span>.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                ((*pair).<span class="number">0</span> + (*pair).<span class="number">1</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                MapType::Identical,</span><br><span class="line">                MapPermission::R | MapPermission::W,</span><br><span class="line">            ),</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    memory_set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/kernel-as-high.png" alt="高256G内核地址空间">]<br>首先将内核strampoline段映射到内核地址空间最高的一页中</p>
<p><img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/kernel-as-low.png" alt="低256G内核地址空间">]</p>
<ul>
<li>内核的.text .rodata .data .bss .kernel段恒等映射到内核地址空间中，</li>
<li>剩下物理内存[ekernel,MEMORY_END)恒等映射到内核地址空间中。</li>
<li>MMIO段也映射到内核地址空间中，用来使用块设备</li>
</ul>
<h4 id="启用MMU"><a href="#启用MMU" class="headerlink" title="启用MMU"></a>启用MMU</h4><p>至此我们就完成了内核地址空间的初始化。此后就可以启用MMU来使用虚拟地址了。<br><img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/satp.png" alt="启用MMU"><br>上图是 RV64 架构下 satp 的字段分布。当 MODE 设置为 0 的时候，所有访存都被视为物理地址；而设置为 8 时，SV39 分页机制被启用，所有 S&#x2F;U 特权级的访存被视为一个 39 位的虚拟地址，MMU 会将其转换成 56 位的物理地址；如果转换失败，则会触发异常。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">activate</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">satp</span> = <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">token</span>();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        satp::<span class="title function_ invoke__">write</span>(satp);</span><br><span class="line">        asm!(<span class="string">&quot;sfence.vma&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">token</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="number">8usize</span> &lt;&lt; <span class="number">60</span> | <span class="keyword">self</span>.root_ppn.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>activate函数将内核地址空间的root_ppn作为satp的根节点，并设置satp的MODE为8，即SV39分页机制。mmu就会去查找root_ppn物理页下的页表，然后根据虚拟地址转换成物理地址。</p>
<h2 id="内核中的中断处理"><a href="#内核中的中断处理" class="headerlink" title="内核中的中断处理"></a>内核中的中断处理</h2><p>上面我们启用MMU之后，设置一下内核中的中断处理，以防比如访问了非法地址导致内核没有相应错误输出</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">set_kernel_trap_entry</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">set_kernel_trap_entry</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">__trap_from_kernel</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        stvec::<span class="title function_ invoke__">write</span>(__trap_from_kernel <span class="keyword">as</span> <span class="type">usize</span>, TrapMode::Direct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap_from_kernel</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">use</span> riscv::register::sepc;</span><br><span class="line">    trace!(<span class="string">&quot;stval = &#123;:#x&#125;, sepc = &#123;:#x&#125;&quot;</span>, stval::<span class="title function_ invoke__">read</span>(), sepc::<span class="title function_ invoke__">read</span>());</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;a trap &#123;:?&#125; from kernel!&quot;</span>, scause::<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">cause</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    .section .data</span><br><span class="line">    # emergency stack for kernel trap</span><br><span class="line">    # in order to print trap info even if the kernel stack is corrupted.</span><br><span class="line">__emergency:</span><br><span class="line">    .align 4</span><br><span class="line">    .space 1024 * 4</span><br><span class="line">__emergency_end:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    .section .text</span><br><span class="line">    .globl __trap_from_kernel</span><br><span class="line">    # 2^2=4 bytes aligned for stvec</span><br><span class="line">    .align 2</span><br><span class="line">__trap_from_kernel:</span><br><span class="line">    la sp, __emergency_end</span><br><span class="line">    j trap_from_kernel    </span><br></pre></td></tr></table></figure>
<p>比较简单，先将stvec指向__trap_from_kernel，在.data中分配4k大小的emergency栈，然后将栈指向emergency，跳转到trap_from_kernel，输出错误信息。</p>
<h2 id="启用时钟中断"><a href="#启用时钟中断" class="headerlink" title="启用时钟中断"></a>启用时钟中断</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">enable_timer_interrupt</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        sie::<span class="title function_ invoke__">set_stimer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_next_trigger</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">set_timer</span>(<span class="title function_ invoke__">get_time</span>() + CLOCK_FREQ / TICKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_timer</span>(timer: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">sbi_call</span>(SBI_SET_TIMER, timer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启用时钟中断，设置下一次触发时间，设置定时器。</p>
<h2 id="加载文件系统"><a href="#加载文件系统" class="headerlink" title="加载文件系统"></a>加载文件系统</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="comment">/// 根节点</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> ROOT_INODE: Arc&lt;Inode&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">efs</span> = EasyFileSystem::<span class="title function_ invoke__">open</span>(BLOCK_DEVICE.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">        Arc::<span class="title function_ invoke__">new</span>(EasyFileSystem::<span class="title function_ invoke__">root_inode</span>(&amp;efs))</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内核堆空间创建了文件系统EasyFileSystem，并获取了根目录的inode。</p>
<h2 id="启动Init进程"><a href="#启动Init进程" class="headerlink" title="启动Init进程"></a>启动Init进程</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="comment">/// Creation of initial process</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// the name &quot;initproc&quot; may be changed to any other app name like &quot;usertests&quot;,</span></span><br><span class="line">    <span class="comment">/// but we have user_shell, so we don&#x27;t need to change it.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> INITPROC: Arc&lt;ProcessControlBlock&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">inode</span> = <span class="title function_ invoke__">open_file</span>(<span class="string">&quot;ch8b_initproc&quot;</span>, OpenFlags::RDONLY).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v</span> = inode.<span class="title function_ invoke__">read_all</span>();</span><br><span class="line">        ProcessControlBlock::<span class="title function_ invoke__">new</span>(v.<span class="title function_ invoke__">as_slice</span>())</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过根目录ROOT_INODE打开INIT文件，读取所有文件内容，根据文件内容创建TCB</p>
<h4 id="PCB，进程控制块"><a href="#PCB，进程控制块" class="headerlink" title="PCB，进程控制块"></a>PCB，进程控制块</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ProcessControlBlock</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ProcessControlBlockInner</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> is_zombie: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> memory_set: MemorySet,</span><br><span class="line">    <span class="keyword">pub</span> parent: <span class="type">Option</span>&lt;Weak&lt;ProcessControlBlock&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> children: <span class="type">Vec</span>&lt;Arc&lt;ProcessControlBlock&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="type">i32</span>,</span><br><span class="line">    <span class="keyword">pub</span> fd_table: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> File + <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt;&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> signals: SignalFlags,</span><br><span class="line">    <span class="keyword">pub</span> tasks: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> task_res_allocator: RecycleAllocator,</span><br><span class="line">    <span class="keyword">pub</span> mutex_list: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> Mutex&gt;&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> semaphore_list: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;Arc&lt;Semaphore&gt;&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> condvar_list: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;Arc&lt;Condvar&gt;&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> enable_deadlock: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是TCB的定义，主要包括：</p>
<ul>
<li>pid：进程id，用于标识进程</li>
<li>memory_set：用户的内存地址空间</li>
<li>parent, children： 父子进程关系</li>
<li>fd_table： 文件描述符表</li>
<li>tasks： 线程列表</li>
<li>mutex_list, semaphore_list, condvar_list： 互斥锁、信号量和条件变量列表</li>
</ul>
<p>API:</p>
<ul>
<li><p>new，创建，仅供InitProc使用</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(elf_data: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> Arc&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> (memory_set, ustack_base, entry_point) = MemorySet::<span class="title function_ invoke__">from_elf</span>(elf_data);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pid_handle</span> = <span class="title function_ invoke__">pid_alloc</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = Arc::<span class="title function_ invoke__">new</span>(<span class="keyword">Self</span> &#123;</span><br><span class="line">        pid: pid_handle,</span><br><span class="line">        inner: <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            UPSafeCell::<span class="title function_ invoke__">new</span>(ProcessControlBlockInner &#123;</span><br><span class="line">                is_zombie: <span class="literal">false</span>,</span><br><span class="line">                memory_set,</span><br><span class="line">                parent: <span class="literal">None</span>,</span><br><span class="line">                children: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                exit_code: <span class="number">0</span>,</span><br><span class="line">                fd_table: <span class="built_in">vec!</span>[</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(Stdin)),</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(Stdout)),</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(Stdout)),</span><br><span class="line">                ],</span><br><span class="line">                signals: SignalFlags::<span class="title function_ invoke__">empty</span>(),</span><br><span class="line">                tasks: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                task_res_allocator: RecycleAllocator::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                mutex_list: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                semaphore_list: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                condvar_list: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                enable_deadlock: <span class="literal">false</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task</span> = Arc::<span class="title function_ invoke__">new</span>(TaskControlBlock::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        Arc::<span class="title function_ invoke__">clone</span>(&amp;process),</span><br><span class="line">        ustack_base,</span><br><span class="line">        <span class="literal">true</span>,</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task_inner</span> = task.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx</span> = task_inner.<span class="title function_ invoke__">get_trap_cx</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ustack_top</span> = task_inner.res.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">ustack_top</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">kstack_top</span> = task.kstack.<span class="title function_ invoke__">get_top</span>();</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(task_inner);</span><br><span class="line">    *trap_cx = TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">        entry_point,</span><br><span class="line">        ustack_top,</span><br><span class="line">        KERNEL_SPACE.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">token</span>(),</span><br><span class="line">        kstack_top,</span><br><span class="line">        trap_handler <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    process_inner.tasks.<span class="title function_ invoke__">push</span>(<span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">clone</span>(&amp;task)));</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process_inner);</span><br><span class="line">    <span class="title function_ invoke__">insert_into_pid2process</span>(process.<span class="title function_ invoke__">getpid</span>(), Arc::<span class="title function_ invoke__">clone</span>(&amp;process));</span><br><span class="line">    <span class="title function_ invoke__">add_task</span>(task);</span><br><span class="line">    process</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>创建用户地址空间<br> 将elf文件转换为用户地址空间memory_set::from_elf</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_elf</span>(elf_data: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> (<span class="keyword">Self</span>, <span class="type">usize</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">memory_set</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new_bare</span>();</span><br><span class="line">    memory_set.<span class="title function_ invoke__">map_trampoline</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">elf</span> = xmas_elf::ElfFile::<span class="title function_ invoke__">new</span>(elf_data).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">elf_header</span> = elf.header;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">magic</span> = elf_header.pt1.magic;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(magic, [<span class="number">0x7f</span>, <span class="number">0x45</span>, <span class="number">0x4c</span>, <span class="number">0x46</span>], <span class="string">&quot;invalid elf!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ph_count</span> = elf_header.pt2.<span class="title function_ invoke__">ph_count</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max_end_vpn</span> = <span class="title function_ invoke__">VirtPageNum</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..ph_count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ph</span> = elf.<span class="title function_ invoke__">program_header</span>(i).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">if</span> ph.<span class="title function_ invoke__">get_type</span>().<span class="title function_ invoke__">unwrap</span>() == xmas_elf::program::Type::Load &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">start_va</span>: VirtAddr = (ph.<span class="title function_ invoke__">virtual_addr</span>() <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">end_va</span>: VirtAddr = ((ph.<span class="title function_ invoke__">virtual_addr</span>() + ph.<span class="title function_ invoke__">mem_size</span>()) <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map_perm</span> = MapPermission::U;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">ph_flags</span> = ph.<span class="title function_ invoke__">flags</span>();</span><br><span class="line">            <span class="keyword">if</span> ph_flags.<span class="title function_ invoke__">is_read</span>() &#123;</span><br><span class="line">                map_perm |= MapPermission::R;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ph_flags.<span class="title function_ invoke__">is_write</span>() &#123;</span><br><span class="line">                map_perm |= MapPermission::W;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ph_flags.<span class="title function_ invoke__">is_execute</span>() &#123;</span><br><span class="line">                map_perm |= MapPermission::X;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">map_area</span> = MapArea::<span class="title function_ invoke__">new</span>(start_va, end_va, MapType::Framed, map_perm);</span><br><span class="line">            max_end_vpn = map_area.vpn_range.<span class="title function_ invoke__">get_end</span>();</span><br><span class="line">            memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">                map_area,</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(&amp;elf.input[ph.<span class="title function_ invoke__">offset</span>() <span class="keyword">as</span> <span class="type">usize</span>..(ph.<span class="title function_ invoke__">offset</span>() + ph.<span class="title function_ invoke__">file_size</span>()) <span class="keyword">as</span> <span class="type">usize</span>]),</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">max_end_va</span>: VirtAddr = max_end_vpn.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user_stack_base</span>: <span class="type">usize</span> = max_end_va.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    user_stack_base += PAGE_SIZE;</span><br><span class="line">    (</span><br><span class="line">        memory_set,</span><br><span class="line">        user_stack_base,</span><br><span class="line">        elf.header.pt2.<span class="title function_ invoke__">entry_point</span>() <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/app-as-full.png" alt="用户地址空间"><br> 先映射一个跳板页在高256G空间，一个循环从elf文件中读取数据段以Framed映射方式从0x0地址开始映射<br> 所有数据段映射完成后，插入一个Guard Page，之后的地址作为用户栈底<br> 返回memory_set，用户栈底，程序入口地址</p>
</li>
<li><p>创建主线程TCB<br> 具体内容后面TCB再分析，然后填充了trap_cx，然后通过add_task添加到任务队列中</p>
</li>
</ol>
</li>
<li><p>fork，创建子进程</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fork</span>(<span class="keyword">self</span>: &amp;Arc&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> Arc&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">parent</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">memory_set</span> = MemorySet::<span class="title function_ invoke__">from_existed_user</span>(&amp;parent.memory_set);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pid</span> = <span class="title function_ invoke__">pid_alloc</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">new_fd_table</span>: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> File + <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt;&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">fd</span> <span class="keyword">in</span> parent.fd_table.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(file) = fd &#123;</span><br><span class="line">            new_fd_table.<span class="title function_ invoke__">push</span>(<span class="title function_ invoke__">Some</span>(file.<span class="title function_ invoke__">clone</span>()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            new_fd_table.<span class="title function_ invoke__">push</span>(<span class="literal">None</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">child</span> = Arc::<span class="title function_ invoke__">new</span>(<span class="keyword">Self</span> &#123;</span><br><span class="line">        pid,</span><br><span class="line">        inner: <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            UPSafeCell::<span class="title function_ invoke__">new</span>(ProcessControlBlockInner &#123;</span><br><span class="line">                is_zombie: <span class="literal">false</span>,</span><br><span class="line">                memory_set,</span><br><span class="line">                parent: <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">downgrade</span>(<span class="keyword">self</span>)),</span><br><span class="line">                children: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                exit_code: <span class="number">0</span>,</span><br><span class="line">                fd_table: new_fd_table,</span><br><span class="line">                signals: SignalFlags::<span class="title function_ invoke__">empty</span>(),</span><br><span class="line">                tasks: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                task_res_allocator: RecycleAllocator::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                mutex_list: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                semaphore_list: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                condvar_list: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                enable_deadlock: <span class="literal">false</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    parent.children.<span class="title function_ invoke__">push</span>(Arc::<span class="title function_ invoke__">clone</span>(&amp;child));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task</span> = Arc::<span class="title function_ invoke__">new</span>(TaskControlBlock::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        Arc::<span class="title function_ invoke__">clone</span>(&amp;child),</span><br><span class="line">        parent</span><br><span class="line">            .<span class="title function_ invoke__">get_task</span>(<span class="number">0</span>)</span><br><span class="line">            .<span class="title function_ invoke__">inner_exclusive_access</span>()</span><br><span class="line">            .res</span><br><span class="line">            .<span class="title function_ invoke__">as_ref</span>()</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">            .<span class="title function_ invoke__">ustack_base</span>(),</span><br><span class="line">        <span class="comment">// here we do not allocate trap_cx or ustack again</span></span><br><span class="line">        <span class="comment">// but mention that we allocate a new kstack here</span></span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">child_inner</span> = child.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    child_inner.tasks.<span class="title function_ invoke__">push</span>(<span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">clone</span>(&amp;task)));</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(child_inner);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task_inner</span> = task.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx</span> = task_inner.<span class="title function_ invoke__">get_trap_cx</span>();</span><br><span class="line">    trap_cx.kernel_sp = task.kstack.<span class="title function_ invoke__">get_top</span>();</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(task_inner);</span><br><span class="line">    <span class="title function_ invoke__">insert_into_pid2process</span>(child.<span class="title function_ invoke__">getpid</span>(), Arc::<span class="title function_ invoke__">clone</span>(&amp;child));</span><br><span class="line">    <span class="title function_ invoke__">add_task</span>(task);</span><br><span class="line">    child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建用户地址空间<br> 通过父进程的memory_set创建子进程的memory_set <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_existed_user</span>(user_space: &amp;<span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">memory_set</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new_bare</span>();</span><br><span class="line">    memory_set.<span class="title function_ invoke__">map_trampoline</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">area</span> <span class="keyword">in</span> user_space.areas.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">new_area</span> = MapArea::<span class="title function_ invoke__">from_another</span>(area);</span><br><span class="line">        memory_set.<span class="title function_ invoke__">push</span>(new_area, <span class="literal">None</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">vpn</span> <span class="keyword">in</span> area.vpn_range &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">src_ppn</span> = user_space.<span class="title function_ invoke__">translate</span>(vpn).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">dst_ppn</span> = memory_set.<span class="title function_ invoke__">translate</span>(vpn).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">            dst_ppn</span><br><span class="line">                .<span class="title function_ invoke__">get_bytes_array</span>()</span><br><span class="line">                .<span class="title function_ invoke__">copy_from_slice</span>(src_ppn.<span class="title function_ invoke__">get_bytes_array</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memory_set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 需要手动映射一下跳板页，之后将父进程中的逻辑段添加到子进程的memory_set中，并且将父进程逻辑段物理页中的数据copy到新物理页中</li>
<li>创建子进程的主线程<br> 这里不用再次创建trap_cx和ustack，因为之前父进程已经创建了映射在memory_set中了<br> 但是这里需要手动创建一个内核栈<br> 仅修改trap_cx的kernel_sp，然后将新的主线程add_task加入调度</li>
</ol>
</li>
<li><p>exec，执行新文件</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exec</span>(<span class="keyword">self</span>: &amp;Arc&lt;<span class="keyword">Self</span>&gt;, elf_data: &amp;[<span class="type">u8</span>], args: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> (memory_set, ustack_base, entry_point) = MemorySet::<span class="title function_ invoke__">from_elf</span>(elf_data);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_token</span> = memory_set.<span class="title function_ invoke__">token</span>();</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">inner_exclusive_access</span>().memory_set = memory_set;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">inner_exclusive_access</span>().<span class="title function_ invoke__">get_task</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">task_inner</span> = task.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    task_inner.res.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>().ustack_base = ustack_base;</span><br><span class="line">    task_inner.res.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">alloc_user_res</span>();</span><br><span class="line">    task_inner.trap_cx_ppn = task_inner.res.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">trap_cx_ppn</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user_sp</span> = task_inner.res.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">ustack_top</span>();</span><br><span class="line">    user_sp -= (args.<span class="title function_ invoke__">len</span>() + <span class="number">1</span>) * core::mem::size_of::&lt;<span class="type">usize</span>&gt;();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">argv_base</span> = user_sp;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">argv</span>: <span class="type">Vec</span>&lt;_&gt; = (<span class="number">0</span>..=args.<span class="title function_ invoke__">len</span>())</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|arg| &#123;</span><br><span class="line">            <span class="title function_ invoke__">translated_refmut</span>(</span><br><span class="line">                new_token,</span><br><span class="line">                (argv_base + arg * core::mem::size_of::&lt;<span class="type">usize</span>&gt;()) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">usize</span>,</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    *argv[args.<span class="title function_ invoke__">len</span>()] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..args.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        user_sp -= args[i].<span class="title function_ invoke__">len</span>() + <span class="number">1</span>;</span><br><span class="line">        *argv[i] = user_sp;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = user_sp;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> args[i].<span class="title function_ invoke__">as_bytes</span>() &#123;</span><br><span class="line">            *<span class="title function_ invoke__">translated_refmut</span>(new_token, p <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>) = *c;</span><br><span class="line">            p += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *<span class="title function_ invoke__">translated_refmut</span>(new_token, p <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>) = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    user_sp -= user_sp % core::mem::size_of::&lt;<span class="type">usize</span>&gt;();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">trap_cx</span> = TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">        entry_point,</span><br><span class="line">        user_sp,</span><br><span class="line">        KERNEL_SPACE.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">token</span>(),</span><br><span class="line">        task.kstack.<span class="title function_ invoke__">get_top</span>(),</span><br><span class="line">        trap_handler <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">    );</span><br><span class="line">    trap_cx.x[<span class="number">10</span>] = args.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    trap_cx.x[<span class="number">11</span>] = argv_base;</span><br><span class="line">    *task_inner.<span class="title function_ invoke__">get_trap_cx</span>() = trap_cx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>替换用户地址空间<br> 通过elf_data创建新的用户地址空间，并替换原有的memory_set<br> 此时就需要创建新的ustack和trap_cx了，因为旧的已经被替换。</li>
<li>压入参数<br> <img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/user-stack-cmdargs.png" alt="参数"><br> 如上图所示：<br> 从栈顶开始即高地址开始，先压入参数在用户栈上的开始地址，再将参数数据压入</li>
<li>修改trap_cx<br> 先app_init_context创建新trap_cx，然后将x[10],x[11]修改为argc和argv</li>
</ol>
</li>
</ul>
<h4 id="TCB，任务控制块"><a href="#TCB，任务控制块" class="headerlink" title="TCB，任务控制块"></a>TCB，任务控制块</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlock</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> process: Weak&lt;ProcessControlBlock&gt;,</span><br><span class="line">    <span class="keyword">pub</span> kstack: KernelStack,</span><br><span class="line">    inner: UPSafeCell&lt;TaskControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlockInner</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> res: <span class="type">Option</span>&lt;TaskUserRes&gt;,</span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum,</span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> stride: TaskStride,</span><br><span class="line">    <span class="keyword">pub</span> mutex_cnt: <span class="type">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> semaphore_cnt: BTreeMap&lt;<span class="type">usize</span>, <span class="type">isize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面为TCB的定义，关键的字段如下：</p>
<ul>
<li>kstack：内核栈，每个线程都有独立的内核栈</li>
<li>res：线程资源  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskUserRes</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> tid: <span class="type">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> ustack_base: <span class="type">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> process: Weak&lt;ProcessControlBlock&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>tid：线程id</li>
<li>ustack_base：用户栈底</li>
</ul>
</li>
<li>task_cx：线程上下文，用于切换线程  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskContext</span> &#123;</span><br><span class="line">    ra: <span class="type">usize</span>,</span><br><span class="line">    sp: <span class="type">usize</span>,</span><br><span class="line">    s: [<span class="type">usize</span>; <span class="number">12</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  包括ra为返回地址，sp为栈顶，s为保存的寄存器</li>
<li>task_status：线程状态，包括running, ready, blocked</li>
<li>exit_code： 线程退出码</li>
</ul>
<p>API：</p>
<ul>
<li>new，创建TCB  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(</span><br><span class="line">    process: Arc&lt;ProcessControlBlock&gt;,</span><br><span class="line">    ustack_base: <span class="type">usize</span>,</span><br><span class="line">    alloc_user_res: <span class="type">bool</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = TaskUserRes::<span class="title function_ invoke__">new</span>(Arc::<span class="title function_ invoke__">clone</span>(&amp;process), ustack_base, alloc_user_res);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx_ppn</span> = res.<span class="title function_ invoke__">trap_cx_ppn</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">kstack</span> = <span class="title function_ invoke__">kstack_alloc</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">kstack_top</span> = kstack.<span class="title function_ invoke__">get_top</span>();</span><br><span class="line">    <span class="keyword">Self</span> &#123;</span><br><span class="line">        process: Arc::<span class="title function_ invoke__">downgrade</span>(&amp;process),</span><br><span class="line">        kstack,</span><br><span class="line">        inner: <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            UPSafeCell::<span class="title function_ invoke__">new</span>(TaskControlBlockInner &#123;</span><br><span class="line">                res: <span class="title function_ invoke__">Some</span>(res),</span><br><span class="line">                trap_cx_ppn,</span><br><span class="line">                task_cx: TaskContext::<span class="title function_ invoke__">goto_trap_return</span>(kstack_top),</span><br><span class="line">                task_status: TaskStatus::Ready,</span><br><span class="line">                exit_code: <span class="literal">None</span>,</span><br><span class="line">                stride: TaskStride::<span class="title function_ invoke__">default</span>(),</span><br><span class="line">                mutex_cnt: <span class="number">0</span>,</span><br><span class="line">                semaphore_cnt: BTreeMap::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>创建用户资源</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(</span><br><span class="line">    process: Arc&lt;ProcessControlBlock&gt;,</span><br><span class="line">    ustack_base: <span class="type">usize</span>,</span><br><span class="line">    alloc_user_res: <span class="type">bool</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tid</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>().<span class="title function_ invoke__">alloc_tid</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task_user_res</span> = <span class="keyword">Self</span> &#123;</span><br><span class="line">        tid,</span><br><span class="line">        ustack_base,</span><br><span class="line">        process: Arc::<span class="title function_ invoke__">downgrade</span>(&amp;process),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> alloc_user_res &#123;</span><br><span class="line">        task_user_res.<span class="title function_ invoke__">alloc_user_res</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    task_user_res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 先分配tid，再根据是否需要分配资源来创建用户资源<code>这里就是为了区分fork</code><br> 用户资源包括了：ustack和trap_cx</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">alloc_user_res</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="keyword">self</span>.process.<span class="title function_ invoke__">upgrade</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ustack_bottom</span> = <span class="title function_ invoke__">ustack_bottom_from_tid</span>(<span class="keyword">self</span>.ustack_base, <span class="keyword">self</span>.tid);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ustack_top</span> = ustack_bottom + USER_STACK_SIZE;</span><br><span class="line">    process_inner.memory_set.<span class="title function_ invoke__">insert_framed_area</span>(</span><br><span class="line">        ustack_bottom.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        ustack_top.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        MapPermission::R | MapPermission::W | MapPermission::U,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// alloc trap_cx</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx_bottom</span> = <span class="title function_ invoke__">trap_cx_bottom_from_tid</span>(<span class="keyword">self</span>.tid);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx_top</span> = trap_cx_bottom + PAGE_SIZE;</span><br><span class="line">    process_inner.memory_set.<span class="title function_ invoke__">insert_framed_area</span>(</span><br><span class="line">        trap_cx_bottom.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        trap_cx_top.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        MapPermission::R | MapPermission::W,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 再用户地址空间上分配ustack和trap_cx<br> 至此用户地址空间如下图：<br> <img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/app-as-full.png" alt="用户地址空间"><br> 用户栈处于低256GB空间，依次排布，中间间隔一个guard_page，<br> trap_cx处于高256GB空间，依次排布，中间间隔一个guard_page</p>
</li>
<li><p>创建内核栈<br> <img src="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/kernel-as-high.png" alt="内核地址空间">]<br> 如上图所示，内核栈处于KERNEL_SPACE的高256GB空间，依次排布，中间间隔一个guard_page</p>
</li>
<li><p>设置task_cx</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">goto_trap_return</span>(kstack_ptr: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">Self</span> &#123;</span><br><span class="line">        ra: trap_return <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">        sp: kstack_ptr,</span><br><span class="line">        s: [<span class="number">0</span>; <span class="number">12</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 创建task_cx，其中ra为trap_return函数的地址，sp为内核栈顶，s全空</p>
</li>
</ol>
</li>
</ul>
<h4 id="创建INITPROC"><a href="#创建INITPROC" class="headerlink" title="创建INITPROC"></a>创建INITPROC</h4><p>至此回顾一下Init进程的创建：</p>
<ul>
<li>通过elf_data创建用户地址空间memory_set，<br>  包括跳板页，.text，.rodata，.data，.bss</li>
<li>创建主线程TCB<br>  分配内核栈kstack，用户栈ustack</li>
<li>设置task_cx<br>  将其设置为ra: trap_return, sp: kstack_top, 其他寄存器为0</li>
<li>设置trap_cx<br>  将entry_point指向init入口，<br>  sp为ustack_top<br>  kernel_satp指向KERNEL_SPACE<br>  kernel_sp指向当前线程kstack_top<br>  trap_handler指向trap_handler</li>
<li>将主线程加入调度，将process加入pid管理</li>
</ul>
<h2 id="初次调度任务"><a href="#初次调度任务" class="headerlink" title="初次调度任务"></a>初次调度任务</h2><p>至此创建完Init进程，并将Init的主线程加入调度，可以开始调度任务了。</p>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">    current: <span class="type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">    idle_task_cx: TaskContext,</span><br><span class="line">&#125;</span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> PROCESSOR: UPSafeCell&lt;Processor&gt; = <span class="keyword">unsafe</span> &#123; UPSafeCell::<span class="title function_ invoke__">new</span>(Processor::<span class="title function_ invoke__">new</span>()) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>current：当前正在执行的线程</li>
<li>idle_task_cx：空闲流<br>关于执行流和空闲流理解：<br>内核本身调度时是有上下文的，比如此时的内核栈是再KERNEL_SPACE的低256GB空间中。<br>当切换到执行流时，内核的上下文也要切换到执行流的上下文，比如执行流的内核栈是再KERNEL_SPACE的高256GB空间中。</li>
</ul>
<p>API:</p>
<ul>
<li>new  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">Self</span> &#123;</span><br><span class="line">        current: <span class="literal">None</span>,</span><br><span class="line">        idle_task_cx: TaskContext::<span class="title function_ invoke__">zero_init</span>(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  初始化全空current和idle_task_cx</li>
<li>take_current  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">take_current</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.current.<span class="title function_ invoke__">take</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  消费current任务，拿到current的所有权</li>
<li>current  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">current</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.current.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">map</span>(Arc::clone)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  仅获取current的引用，本身所有权仍属于Processor</li>
</ul>
<h3 id="线程管理器"><a href="#线程管理器" class="headerlink" title="线程管理器"></a>线程管理器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line">    ready_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">    stop_task: <span class="type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> TASK_MANAGER: UPSafeCell&lt;TaskManager&gt; =</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; UPSafeCell::<span class="title function_ invoke__">new</span>(TaskManager::<span class="title function_ invoke__">new</span>()) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ready_queue：就绪队列</li>
<li>stop_task：停止中任务</li>
</ul>
<p>API:</p>
<ul>
<li>new, 创建  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">Self</span> &#123;</span><br><span class="line">        ready_queue: VecDeque::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        stop_task: <span class="literal">None</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  初始化ready_queue为VecDeque，stop_task为None</li>
<li>add, 添加任务  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, task: Arc&lt;TaskControlBlock&gt;) &#123;</span><br><span class="line">    <span class="keyword">self</span>.ready_queue.<span class="title function_ invoke__">push_back</span>(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  添加任务到ready_queue</li>
<li>remove, 移除任务  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fetch</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.ready_queue.<span class="title function_ invoke__">pop_front</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  移除ready_queue中的第一个任务</li>
<li>add_stop, 添加停止中任务  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_stop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, task: Arc&lt;TaskControlBlock&gt;) &#123;</span><br><span class="line">    <span class="keyword">self</span>.stop_task = <span class="title function_ invoke__">Some</span>(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="调度任务"><a href="#调度任务" class="headerlink" title="调度任务"></a>调度任务</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run_tasks</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">processor</span> = PROCESSOR.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = <span class="title function_ invoke__">fetch_task</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">idle_task_cx_ptr</span> = processor.<span class="title function_ invoke__">get_idle_task_cx_ptr</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">task_inner</span> = task.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">next_task_cx_ptr</span> = &amp;task_inner.task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line">            task_inner.task_status = TaskStatus::Running;</span><br><span class="line">            <span class="title function_ invoke__">drop</span>(task_inner);</span><br><span class="line">            processor.current = <span class="title function_ invoke__">Some</span>(task);</span><br><span class="line">            <span class="title function_ invoke__">drop</span>(processor);</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                __switch(idle_task_cx_ptr, next_task_cx_ptr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            warn!(<span class="string">&quot;no tasks available in run_tasks&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获取就绪任务<br> 通过fetch_task，从TASK_MANAGER中获取就绪任务</li>
<li>task所有权传递<br> Processor中current为设置为新任务，丢弃之前的current<br> task的所有权从TASK_MANAGER-&gt;PROCESSOR</li>
<li>切换上下文<br> 通过__switch，将当前即idle的上下文切换到新任务的上下文</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">schedule</span>(switched_task_cx_ptr: *<span class="keyword">mut</span> TaskContext) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">processor</span> = PROCESSOR.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">idle_task_cx_ptr</span> = processor.<span class="title function_ invoke__">get_idle_task_cx_ptr</span>();</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(processor);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __switch(switched_task_cx_ptr, idle_task_cx_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>schedule，将当前任务切换到idle流上</p>
<h3 id="任务上下文切换"><a href="#任务上下文切换" class="headerlink" title="任务上下文切换"></a>任务上下文切换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_SN n</span><br><span class="line">    sd s\n, (\n+2)*8(a0)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_SN n</span><br><span class="line">    ld s\n, (\n+2)*8(a1)</span><br><span class="line">.endm</span><br><span class="line">    .section .text</span><br><span class="line">    .globl __switch</span><br><span class="line">__switch:</span><br><span class="line">    # __switch(</span><br><span class="line">    #     current_task_cx_ptr: *mut TaskContext,</span><br><span class="line">    #     next_task_cx_ptr: *const TaskContext</span><br><span class="line">    # )</span><br><span class="line">    # save kernel stack of current task</span><br><span class="line">    sd sp, 8(a0)</span><br><span class="line">    # save ra &amp; s0~s11 of current execution</span><br><span class="line">    sd ra, 0(a0)</span><br><span class="line">    .set n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        SAVE_SN %n</span><br><span class="line">        .set n, n + 1</span><br><span class="line">    .endr</span><br><span class="line">    # restore ra &amp; s0~s11 of next execution</span><br><span class="line">    ld ra, 0(a1)</span><br><span class="line">    .set n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        LOAD_SN %n</span><br><span class="line">        .set n, n + 1</span><br><span class="line">    .endr</span><br><span class="line">    # restore kernel stack of next task</span><br><span class="line">    ld sp, 8(a1)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>回顾TaskContext结构体：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskContext</span> &#123;</span><br><span class="line">    ra: <span class="type">usize</span>,</span><br><span class="line">    sp: <span class="type">usize</span>,</span><br><span class="line">    s: [<span class="type">usize</span>; <span class="number">12</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>a0为idle的task_cx，数值全0<br>a1为当前正在执行的task_cx，此时为Init，</p>
<ul>
<li>ra为trap_return,</li>
<li>sp为init的kstack_top</li>
<li>s全为0<br>__switch函数，先将当前idle的上下文保存在Processor的idle_task_cx，<br>之后从task_cx中将寄存器值加载进来，<br>至此内核上下文切换完成，接下来通过ret跳转到ra，即trap_return。</li>
</ul>
<h2 id="内核态和用户态切换"><a href="#内核态和用户态切换" class="headerlink" title="内核态和用户态切换"></a>内核态和用户态切换</h2><h3 id="初次进入用户态"><a href="#初次进入用户态" class="headerlink" title="初次进入用户态"></a>初次进入用户态</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">set_user_trap_entry</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        stvec::<span class="title function_ invoke__">write</span>(TRAMPOLINE <span class="keyword">as</span> <span class="type">usize</span>, TrapMode::Direct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap_return</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">set_user_trap_entry</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx_user_va</span> = <span class="title function_ invoke__">current_trap_cx_user_va</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user_satp</span> = <span class="title function_ invoke__">current_user_token</span>();</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">__alltraps</span>();</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">__restore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">restore_va</span> = __restore <span class="keyword">as</span> <span class="type">usize</span> - __alltraps <span class="keyword">as</span> <span class="type">usize</span> + TRAMPOLINE;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">&quot;fence.i&quot;</span>,</span><br><span class="line">            <span class="string">&quot;jr &#123;restore_va&#125;&quot;</span>,         <span class="comment">// jump to new addr of __restore asm function</span></span><br><span class="line">            restore_va = <span class="title function_ invoke__">in</span>(reg) restore_va,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;a0&quot;</span>) trap_cx_user_va,      <span class="comment">// a0 = virt addr of Trap Context</span></span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;a1&quot;</span>) user_satp,        <span class="comment">// a1 = phy addr of usr page table</span></span><br><span class="line">            <span class="title function_ invoke__">options</span>(noreturn)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>设置用户态的中断入口<br> 这里就是__alltraps的地址，用户态中断后就会到__alltraps中</p>
</li>
<li><p>跳转到__restore<br> 先计算restore的虚拟地址，然后设置a0为当前任务的trap_cx地址（用户地址空间的高256GB中），a1为用户地址空间satp</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TrapContext</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> x: [<span class="type">usize</span>; <span class="number">32</span>],</span><br><span class="line">    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line">    <span class="keyword">pub</span> sepc: <span class="type">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> kernel_satp: <span class="type">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> kernel_sp: <span class="type">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> trap_handler: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 此时的trap_cx内容如下：</p>
<ul>
<li>x: 均为0</li>
<li>sstatus: 设置了SPP::User</li>
<li>sepc：为init的entry_ptr</li>
<li>kernel_satp：内核地址空间satp</li>
<li>kernel_sp：为init的kstack_top</li>
<li>trap_handler：即handler_handler地址</li>
</ul>
</li>
<li><p>准备进入用户态__restore</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">__restore:</span><br><span class="line">    # a0: *TrapContext in user space(Constant); a1: user space token</span><br><span class="line">    # switch to user space</span><br><span class="line">    csrw satp, a1</span><br><span class="line">    sfence.vma</span><br><span class="line">    csrw sscratch, a0</span><br><span class="line">    mv sp, a0</span><br><span class="line">    # now sp points to TrapContext in user space, start restoring based on it</span><br><span class="line">    # restore sstatus/sepc</span><br><span class="line">    ld t0, 32*8(sp)</span><br><span class="line">    ld t1, 33*8(sp)</span><br><span class="line">    csrw sstatus, t0</span><br><span class="line">    csrw sepc, t1</span><br><span class="line">    # restore general purpose registers except x0/sp/tp</span><br><span class="line">    ld x1, 1*8(sp)</span><br><span class="line">    ld x3, 3*8(sp)</span><br><span class="line">    .set n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        LOAD_GP %n</span><br><span class="line">        .set n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    # back to user stack</span><br><span class="line">    ld sp, 2*8(sp)</span><br><span class="line">    sret</span><br></pre></td></tr></table></figure>
<ul>
<li>先切换mmu，使用户地址空间的satp，sfence.vma刷新tlb</li>
<li>保存sscratch为trap_cx的地址</li>
<li>之后从trap_cx中恢复sstatus和sepc</li>
<li>恢复通用寄存器除了x0&#x2F;sp&#x2F;tp，这里一开始全为0</li>
<li>最后恢复sp，刚开始也是0</li>
<li>调用sret，进入用户态</li>
</ul>
</li>
</ol>
<h3 id="返回内核态"><a href="#返回内核态" class="headerlink" title="返回内核态"></a>返回内核态</h3><p>在进入用户态之前，设置了中断处理器，当用户态发生中断时，会调用__alltraps。进入内核态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__alltraps:</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    # now sp-&gt;*TrapContext in user space, sscratch-&gt;user stack</span><br><span class="line">    # save other general purpose registers</span><br><span class="line">    sd x1, 1*8(sp)</span><br><span class="line">    # skip sp(x2), we will save it later</span><br><span class="line">    sd x3, 3*8(sp)</span><br><span class="line">    # skip tp(x4), application does not use it</span><br><span class="line">    # save x5~x31</span><br><span class="line">    .set n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        SAVE_GP %n</span><br><span class="line">        .set n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    # we can use t0/t1/t2 freely, because they have been saved in TrapContext</span><br><span class="line">    csrr t0, sstatus</span><br><span class="line">    csrr t1, sepc</span><br><span class="line">    sd t0, 32*8(sp)</span><br><span class="line">    sd t1, 33*8(sp)</span><br><span class="line">    # read user stack from sscratch and save it in TrapContext</span><br><span class="line">    csrr t2, sscratch</span><br><span class="line">    sd t2, 2*8(sp)</span><br><span class="line">    # load kernel_satp into t0</span><br><span class="line">    ld t0, 34*8(sp)</span><br><span class="line">    # load trap_handler into t1</span><br><span class="line">    ld t1, 36*8(sp)</span><br><span class="line">    # move to kernel_sp</span><br><span class="line">    ld sp, 35*8(sp)</span><br><span class="line">    # switch to kernel space</span><br><span class="line">    csrw satp, t0</span><br><span class="line">    sfence.vma</span><br><span class="line">    # jump to trap_handler</span><br><span class="line">    jr t1</span><br></pre></td></tr></table></figure>
<ul>
<li>交换sp, sscratch<br>  上面进入用户态前，sscratch保存了trap_cx的地址。<br>  交换后，sp为trap_cx的地址，sscratch为user stack</li>
<li>保存通用寄存器跳过x2,x4</li>
<li>保存sstatus和sepc</li>
<li>将sscratch保存到trap_cx的sp中，因为上面交换后，sscratch即用户栈</li>
<li>从trap_cx中恢复kernel_satp和kernel_sp</li>
<li>切换到内核地址空间</li>
<li>跳转到trap_handler<br>至此就切换到了内核态，此时的内核栈是Init的kstack，接下来就是中断处理</li>
</ul>
<h3 id="再次进入用户态"><a href="#再次进入用户态" class="headerlink" title="再次进入用户态"></a>再次进入用户态</h3><p>以系统调用为例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Trap::<span class="title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">        <span class="comment">// jump to next instruction anyway</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cx</span> = <span class="title function_ invoke__">current_trap_cx</span>();</span><br><span class="line">        cx.sepc += <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// get system call return value</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">syscall</span>(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>], cx.x[<span class="number">13</span>]]);</span><br><span class="line">        <span class="comment">// cx is changed during sys_exec, so we have to call it again</span></span><br><span class="line">        cx = <span class="title function_ invoke__">current_trap_cx</span>();</span><br><span class="line">        cx.x[<span class="number">10</span>] = result <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">trap_return</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>跳过当前ecall指令，ecall指令长度4</li>
<li>重新获取trap_cx，设置x10为返回值，因为sys_exec会修改trap_cx，所以再次获取</li>
<li>调用trap_return，同第一次进入用户态一样，只不过此时trap_cx中已经保留用户态的上下文信息</li>
</ol>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MutexBlocking</span> &#123;</span><br><span class="line">    inner: UPSafeCell&lt;MutexBlockingInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MutexBlockingInner</span> &#123;</span><br><span class="line">    locked: <span class="type">bool</span>,</span><br><span class="line">    wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>locked，表示是否被锁住</li>
<li>wait_queue，表示等待的队列</li>
</ul>
<p>API:</p>
<ul>
<li>lock  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutex_inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">if</span> mutex_inner.locked &#123;</span><br><span class="line">        mutex_inner.wait_queue.<span class="title function_ invoke__">push_back</span>(<span class="title function_ invoke__">current_task</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(mutex_inner);</span><br><span class="line">        <span class="title function_ invoke__">block_current_and_run_next</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mutex_inner.locked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判断是否被锁住，如果被锁住，则将当前任务加入等待队列，并阻塞当前任务</li>
<li>如果没有被锁住，则直接将锁标记为true</li>
</ol>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">block_current_and_run_next</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task</span> = <span class="title function_ invoke__">take_current_task</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">task_inner</span> = task.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task_cx_ptr</span> = &amp;<span class="keyword">mut</span> task_inner.task_cx <span class="keyword">as</span> *<span class="keyword">mut</span> TaskContext;</span><br><span class="line">    task_inner.task_status = TaskStatus::Blocked;</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(task_inner);</span><br><span class="line">    <span class="title function_ invoke__">schedule</span>(task_cx_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  获取当前任务所有权，设置为阻塞状态，并通过schedule切换到idle流</p>
</li>
<li>unlock  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">unlock</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutex_inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(mutex_inner.locked);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(waking_task) = mutex_inner.wait_queue.<span class="title function_ invoke__">pop_front</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">wakeup_task</span>(waking_task);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mutex_inner.locked = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判断等待队列是否为空，不空唤醒等待队列中的第一个任务</li>
<li>如果为空，则将锁标记为false</li>
</ol>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">wakeup_task</span>(task: Arc&lt;TaskControlBlock&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">task_inner</span> = task.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    task_inner.task_status = TaskStatus::Ready;</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(task_inner);</span><br><span class="line">    <span class="title function_ invoke__">add_task</span>(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  将任务加入就绪队列</p>
</li>
</ul>
<p>由于锁资源是进程共享的，所有保存在PCB中</p>
<h4 id="互斥锁创建"><a href="#互斥锁创建" class="headerlink" title="互斥锁创建"></a>互斥锁创建</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_mutex_create</span>(blocking: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex</span>: <span class="type">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> Mutex&gt;&gt; = <span class="keyword">if</span> !blocking &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(MutexSpin::<span class="title function_ invoke__">new</span>()))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(MutexBlocking::<span class="title function_ invoke__">new</span>()))</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(id) = process_inner</span><br><span class="line">        .mutex_list</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">enumerate</span>()</span><br><span class="line">        .<span class="title function_ invoke__">find</span>(|(_, item)| item.<span class="title function_ invoke__">is_none</span>())</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|(id, _)| id)</span><br><span class="line">    &#123;</span><br><span class="line">        process_inner.mutex_list[id] = mutex;</span><br><span class="line">        id <span class="keyword">as</span> <span class="type">isize</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        process_inner.mutex_list.<span class="title function_ invoke__">push</span>(mutex);</span><br><span class="line">        process_inner.mutex_list.<span class="title function_ invoke__">len</span>() <span class="keyword">as</span> <span class="type">isize</span> - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，创建一个Mutex，保存在PCB的mutex_list中</p>
<h4 id="互斥锁使用"><a href="#互斥锁使用" class="headerlink" title="互斥锁使用"></a>互斥锁使用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_mutex_lock</span>(mutex_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">clone</span>(process_inner.mutex_list[mutex_id].<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process_inner);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process);</span><br><span class="line">    mutex.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_mutex_unlock</span>(mutex_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">clone</span>(process_inner.mutex_list[mutex_id].<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process_inner);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process);</span><br><span class="line">    mutex.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用也比较简单，通过mutex_id获取Mutex，然后调用lock和unlock<br>现在讨论一下整个过程中的程序行为：</p>
<ol>
<li>创建互斥锁，创建一个Mutex，保存在PCB的mutex_list中</li>
<li>线程1调用lock，此时locked为true</li>
<li>线程2调用lock，发现locked为true，tcb保存在mutex的wait_queue中，将执行流中的current保存在内核栈上</li>
<li>线程1调用unlock，tcb从mutex的wait_queue中取出，加入TASK_MANAGER</li>
<li>线程2恢复执行，回到block_current_and_run_next中，返回task被丢弃，仅存在一份在Processor<br>整个过程中task的所有权从Processor中转移到mutex_list的wait_queue中，然后重新加入到TASK_MANAGER中，最后重新会到Processor中</li>
</ol>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Semaphore</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> inner: UPSafeCell&lt;SemaphoreInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SemaphoreInner</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> count: <span class="type">isize</span>,</span><br><span class="line">    <span class="keyword">pub</span> wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>count，表示信号量的值</li>
<li>wait_queue，表示等待的队列</li>
</ul>
<p>API:</p>
<ul>
<li>up，V操作  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">up</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    inner.count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> inner.count &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = inner.wait_queue.<span class="title function_ invoke__">pop_front</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">wakeup_task</span>(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>将count加1</li>
<li>如果count小于等于0，则从wait_queue中取出一个任务，唤醒该任务<br> 因为P操作是count-1，count小于0说明有任务在等待</li>
</ol>
</li>
<li>down，P操作  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">down</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    inner.count -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> inner.count &lt; <span class="number">0</span> &#123;</span><br><span class="line">        inner.wait_queue.<span class="title function_ invoke__">push_back</span>(<span class="title function_ invoke__">current_task</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(inner);</span><br><span class="line">        <span class="title function_ invoke__">block_current_and_run_next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>将count减1，如果count小于0，则将当前任务加入等待队列，并阻塞当前任务</li>
</ol>
</li>
</ul>
<p>实际syscall_调用也比较简单，不再赘述</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_semaphore_create</span>(res_count: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id</span> = <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(id) = process_inner</span><br><span class="line">        .semaphore_list</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">enumerate</span>()</span><br><span class="line">        .<span class="title function_ invoke__">find</span>(|(_, item)| item.<span class="title function_ invoke__">is_none</span>())</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|(id, _)| id)</span><br><span class="line">    &#123;</span><br><span class="line">        process_inner.semaphore_list[id] = <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(Semaphore::<span class="title function_ invoke__">new</span>(res_count)));</span><br><span class="line">        id</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        process_inner</span><br><span class="line">            .semaphore_list</span><br><span class="line">            .<span class="title function_ invoke__">push</span>(<span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(Semaphore::<span class="title function_ invoke__">new</span>(res_count))));</span><br><span class="line">        process_inner.semaphore_list.<span class="title function_ invoke__">len</span>() - <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    id <span class="keyword">as</span> <span class="type">isize</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// semaphore up syscall</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_semaphore_up</span>(sem_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sem</span> = Arc::<span class="title function_ invoke__">clone</span>(process_inner.semaphore_list[sem_id].<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process_inner);</span><br><span class="line">    sem.<span class="title function_ invoke__">up</span>();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// semaphore down syscall</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_semaphore_down</span>(sem_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sem</span> = Arc::<span class="title function_ invoke__">clone</span>(process_inner.semaphore_list[sem_id].<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process_inner);</span><br><span class="line">    sem.<span class="title function_ invoke__">down</span>();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> inner: UPSafeCell&lt;CondvarInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CondvarInner</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue，表示等待的队列</li>
</ul>
<p>API:</p>
<ul>
<li>signal  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">signal</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = inner.wait_queue.<span class="title function_ invoke__">pop_front</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">wakeup_task</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  唤醒wait_queue中的第一个任务</li>
<li>wait  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">wait</span>(&amp;<span class="keyword">self</span>, mutex: Arc&lt;<span class="keyword">dyn</span> Mutex&gt;) &#123;</span><br><span class="line">    mutex.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    inner.wait_queue.<span class="title function_ invoke__">push_back</span>(<span class="title function_ invoke__">current_task</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(inner);</span><br><span class="line">    <span class="title function_ invoke__">block_current_and_run_next</span>();</span><br><span class="line">    mutex.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  解锁mutex，将当前task加入wait_queue，阻塞当前task调度下一个任务<br>  加锁mutex</li>
</ul>
<p>对应的syscall如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_condvar_create</span>() <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id</span> = <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(id) = process_inner</span><br><span class="line">        .condvar_list</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">enumerate</span>()</span><br><span class="line">        .<span class="title function_ invoke__">find</span>(|(_, item)| item.<span class="title function_ invoke__">is_none</span>())</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|(id, _)| id)</span><br><span class="line">    &#123;</span><br><span class="line">        process_inner.condvar_list[id] = <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(Condvar::<span class="title function_ invoke__">new</span>()));</span><br><span class="line">        id</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        process_inner</span><br><span class="line">            .condvar_list</span><br><span class="line">            .<span class="title function_ invoke__">push</span>(<span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(Condvar::<span class="title function_ invoke__">new</span>())));</span><br><span class="line">        process_inner.condvar_list.<span class="title function_ invoke__">len</span>() - <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    id <span class="keyword">as</span> <span class="type">isize</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// condvar signal syscall</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_condvar_signal</span>(condvar_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">condvar</span> = Arc::<span class="title function_ invoke__">clone</span>(process_inner.condvar_list[condvar_id].<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process_inner);</span><br><span class="line">    condvar.<span class="title function_ invoke__">signal</span>();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// condvar wait syscall</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_condvar_wait</span>(condvar_id: <span class="type">usize</span>, mutex_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process</span> = <span class="title function_ invoke__">current_process</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process_inner</span> = process.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">condvar</span> = Arc::<span class="title function_ invoke__">clone</span>(process_inner.condvar_list[condvar_id].<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">clone</span>(process_inner.mutex_list[mutex_id].<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(process_inner);</span><br><span class="line">    condvar.<span class="title function_ invoke__">wait</span>(mutex);</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://rubick-hqm.github.io/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="cm9wq95te0003z8vj8gg3azd0" data-title="操作系统_总结" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统_文件系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2025-04-19T04:37:54.366Z" itemprop="datePublished">2025-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">操作系统_文件系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>以下是参加清华大学2025 春夏季开源操作系统训练营学习blog。<br>本节关于操作系统的文件系统相关的内容。</p>
<h1 id="API方向"><a href="#API方向" class="headerlink" title="API方向"></a>API方向</h1><p>我们先从API的方向来分析文件系统，底层先当作一个黑盒，先看看如何使用文件系统来操作文件。</p>
<h2 id="EasyFileSystem数据结构"><a href="#EasyFileSystem数据结构" class="headerlink" title="EasyFileSystem数据结构"></a>EasyFileSystem数据结构</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">EasyFileSystem</span> &#123;</span><br><span class="line">    <span class="comment">///Real device</span></span><br><span class="line">    <span class="keyword">pub</span> block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">    <span class="comment">///Inode bitmap</span></span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap: Bitmap,</span><br><span class="line">    <span class="comment">///Data bitmap</span></span><br><span class="line">    <span class="keyword">pub</span> data_bitmap: Bitmap,</span><br><span class="line">    inode_area_start_block: <span class="type">u32</span>,</span><br><span class="line">    data_area_start_block: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// A bitmap</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Bitmap</span> &#123;</span><br><span class="line">    start_block_id: <span class="type">usize</span>,</span><br><span class="line">    blocks: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是文件系统核心数据结构EasyFileSystem，包含一个实际块设备指针block_device用来真实操作设备，一个bitmap位图表示Inode和Data的分配情况，还有两个u32分别表示Inode和Data的起始块号。<br>这个数据结构存在于内存中，不实际存在于磁盘中，实际磁盘上使用了SuperBlock来表示，并存放在磁盘的0号块中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SuperBlock</span> &#123;</span><br><span class="line">    magic: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> total_blocks: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap_blocks: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> inode_area_blocks: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> data_bitmap_blocks: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> data_area_blocks: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么实际磁盘存储结构可以以下结构表示：<br>| super block | inode_bitmap | inode_area | data_bitmap | data_area |</p>
<h2 id="创建文件镜像"><a href="#创建文件镜像" class="headerlink" title="创建文件镜像"></a>创建文件镜像</h2><p>本章中我们需要使用文件系统来动态加载app，需要创建文件镜像存放app数据。具体代码在easy_fs_pack。<br>首先创建了fs.img，并将其大小设置为16 * 2048 * 512，即16*2048个块</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">block_file</span> = Arc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">BlockFile</span>(Mutex::<span class="title function_ invoke__">new</span>(&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = OpenOptions::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read</span>(<span class="literal">true</span>)</span><br><span class="line">        .<span class="title function_ invoke__">write</span>(<span class="literal">true</span>)</span><br><span class="line">        .<span class="title function_ invoke__">create</span>(<span class="literal">true</span>)</span><br><span class="line">        .<span class="title function_ invoke__">open</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, target_path, <span class="string">&quot;fs.img&quot;</span>))?;</span><br><span class="line">    f.<span class="title function_ invoke__">set_len</span>(<span class="number">16</span> * <span class="number">2048</span> * <span class="number">512</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    f</span><br><span class="line">&#125;)));</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A data block of block size</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">create</span>(</span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">    total_blocks: <span class="type">u32</span>,</span><br><span class="line">    inode_bitmap_blocks: <span class="type">u32</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// calculate block size of areas &amp; create bitmaps</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inode_bitmap</span> = Bitmap::<span class="title function_ invoke__">new</span>(<span class="number">1</span>, inode_bitmap_blocks <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inode_num</span> = inode_bitmap.<span class="title function_ invoke__">maximum</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inode_area_blocks</span> =</span><br><span class="line">        ((inode_num * core::mem::size_of::&lt;DiskInode&gt;() + BLOCK_SZ - <span class="number">1</span>) / BLOCK_SZ) <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inode_total_blocks</span> = inode_bitmap_blocks + inode_area_blocks;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_total_blocks</span> = total_blocks - <span class="number">1</span> - inode_total_blocks;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_bitmap_blocks</span> = (data_total_blocks + <span class="number">4096</span>) / <span class="number">4097</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_area_blocks</span> = data_total_blocks - data_bitmap_blocks;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_bitmap</span> = Bitmap::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        (<span class="number">1</span> + inode_bitmap_blocks + inode_area_blocks) <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">        data_bitmap_blocks <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">efs</span> = <span class="keyword">Self</span> &#123;</span><br><span class="line">        block_device: Arc::<span class="title function_ invoke__">clone</span>(&amp;block_device),</span><br><span class="line">        inode_bitmap,</span><br><span class="line">        data_bitmap,</span><br><span class="line">        inode_area_start_block: <span class="number">1</span> + inode_bitmap_blocks,</span><br><span class="line">        data_area_start_block: <span class="number">1</span> + inode_total_blocks + data_bitmap_blocks,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// clear all blocks</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..total_blocks &#123;</span><br><span class="line">        <span class="title function_ invoke__">get_block_cache</span>(i <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(&amp;block_device))</span><br><span class="line">            .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">modify</span>(<span class="number">0</span>, |data_block: &amp;<span class="keyword">mut</span> DataBlock| &#123;</span><br><span class="line">                <span class="keyword">for</span> <span class="variable">byte</span> <span class="keyword">in</span> data_block.<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">                    *byte = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// initialize SuperBlock</span></span><br><span class="line">    <span class="title function_ invoke__">get_block_cache</span>(<span class="number">0</span>, Arc::<span class="title function_ invoke__">clone</span>(&amp;block_device)).<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">modify</span>(</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        |super_block: &amp;<span class="keyword">mut</span> SuperBlock| &#123;</span><br><span class="line">            super_block.<span class="title function_ invoke__">initialize</span>(</span><br><span class="line">                total_blocks,</span><br><span class="line">                inode_bitmap_blocks,</span><br><span class="line">                inode_area_blocks,</span><br><span class="line">                data_bitmap_blocks,</span><br><span class="line">                data_area_blocks,</span><br><span class="line">            );</span><br><span class="line">        &#125;,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// write back immediately</span></span><br><span class="line">    <span class="comment">// create a inode for root node &quot;/&quot;</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(efs.<span class="title function_ invoke__">alloc_inode</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> (root_inode_block_id, root_inode_offset) = efs.<span class="title function_ invoke__">get_disk_inode_pos</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="title function_ invoke__">get_block_cache</span>(root_inode_block_id <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(&amp;block_device))</span><br><span class="line">        .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">        .<span class="title function_ invoke__">modify</span>(root_inode_offset, |disk_inode: &amp;<span class="keyword">mut</span> DiskInode| &#123;</span><br><span class="line">            disk_inode.<span class="title function_ invoke__">initialize</span>(DiskInodeType::Directory);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="title function_ invoke__">block_cache_sync_all</span>();</span><br><span class="line">    Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(efs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后调用EasyFileSystem::create(block_file, 16 * 2048, 1)来创建文件系统。<br>细细分析下这段代码：</p>
<ul>
<li><p>参数分析：<br>  传入三个参数，block_device: block_file对应我们写入的fs.img镜像，total_blocks: 16*2048表示fs.img镜像块数量，inode_bitmap_blocks：1，表示现在inode块位图占用一个块。</p>
</li>
<li><p>磁盘布局</p>
<ul>
<li>inode_bitmap：从块1开始，占用1块，表示inode块位图。</li>
<li>inode_num：索引数量4096，一共一个块，4096位</li>
<li>inode_area_blocks：4096个DiskNode，DiskNode大小128字节，块512字节，总计1024个</li>
<li>inode_total_blocks：1+1024总共1025个块</li>
<li>data_total_blocks: 除去superblock和inode剩下全是data相关，即16*2048-1-1025&#x3D;31742</li>
<li>data_bitmap_blocks：(31742+4096)&#x2F;4097&#x3D;8，由于一个块的bitmap可以索引4096个数据块，为了最大化使用磁盘，除以4097再向上取整。这里是8，可以索引8*4096&#x3D;32768个数据块，覆盖了上面31742剩余块</li>
<li>data_area_blocks：31742-8&#x3D;31734，即剩余31734个块，用来存放数据。</li>
<li>data_bitmap：从块1+1025开始，占用8块，表示data块位图。</li>
</ul>
<p>  最终磁盘布局如下：<br>  super block: 0<br>  inode_bitmap: 1<br>  inode_area: 2-1025<br>  data_bitmap: 1026-1033<br>  data_area: 1034-31742</p>
</li>
<li><p>初始化数据<br>  由于easy_fs本身很简单，只有一个root目录，之后文件均放在根目录下，所以需要初始根目录，所有操作均通过get_block_cache写入缓存，最终block_cache_sync_all同步到磁盘中。</p>
<ul>
<li>清空所有块，初始化super block</li>
<li>创建根目录：通过alloc_inode分配inode，这是必然为0，再通过get_disk_inode_pos获取inode在哪个块和偏移（因为一个块中有多个DiskNode)，然后写入DiskInode初始化为目录类型</li>
<li>最后block_cache_sync_all同步修改到磁盘中</li>
</ul>
</li>
<li><p>写入app数据<br>  我们的app数据均直接放在root目录下，所以我们需要拿到root_inode，然后创建文件inode，再写入数据</p>
<ul>
<li>通过root_inode拿到root的Inode</li>
<li>遍历所有app，读取app数据，通过Inode::create创建文件inode</li>
<li>通过Inode::write_at写入数据<br>至此我们就完成了fs.img的创建，其中包括了super block用来描述文件系统，创建了root_inode，以及写入了所有app数据。</li>
</ul>
</li>
</ul>
<h2 id="内核中使用文件系统"><a href="#内核中使用文件系统" class="headerlink" title="内核中使用文件系统"></a>内核中使用文件系统</h2><ul>
<li><p>块设备初始化</p>
<ul>
<li>qemu配置了VirtIO 块设备，内存映射 I&#x2F;O (MMIO, Memory-Mapped I&#x2F;O) 指通过特定的物理内存地址来访问外设的设备寄存器。查阅资料，可知 VirtIO 总线的 MMIO 物理地址区间为从 0x10001000 开头的 4KiB。<br>  将这一段物理内存区间直接恒等映射到内核空间。</li>
<li>块设备实例  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/drivers/block/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">BlockDeviceImpl</span> = virtio_blk::VirtIOBlock;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> BLOCK_DEVICE: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt; = Arc::<span class="title function_ invoke__">new</span>(BlockDeviceImpl::<span class="title function_ invoke__">new</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  BLOCK_DEVICE是一个Arc<dyn BlockDevice>，即加载文件系统需要的块设备</li>
</ul>
</li>
<li><p>加载文件系统<br>  我们现在已经有了块设备，可以加载文件系统了。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/fs/inode.rs</span></span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> ROOT_INODE: Arc&lt;Inode&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">efs</span> = EasyFileSystem::<span class="title function_ invoke__">open</span>(BLOCK_DEVICE.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">        Arc::<span class="title function_ invoke__">new</span>(EasyFileSystem::<span class="title function_ invoke__">root_inode</span>(&amp;efs))</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  通过EasyFileSystem::open从BLOCK_DEVICE加载创建EasyFileSystem数据结构到内存中，通过root_inode获取到root_inode，至此我们就可以通过ROOT_INODE访问到文件系统了，就像下面一样。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/fs/inode.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">list_apps</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;/**** APPS ****&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">app</span> <span class="keyword">in</span> ROOT_INODE.<span class="title function_ invoke__">ls</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, app);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;**************/&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  现在回过头分析EasyFileSystem::open</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">open</span>(block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) <span class="punctuation">-&gt;</span> Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// read SuperBlock</span></span><br><span class="line">    <span class="title function_ invoke__">get_block_cache</span>(<span class="number">0</span>, Arc::<span class="title function_ invoke__">clone</span>(&amp;block_device))</span><br><span class="line">        .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read</span>(<span class="number">0</span>, |super_block: &amp;SuperBlock| &#123;</span><br><span class="line">            <span class="built_in">assert!</span>(super_block.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;Error loading EFS!&quot;</span>);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">inode_total_blocks</span> =</span><br><span class="line">                super_block.inode_bitmap_blocks + super_block.inode_area_blocks;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">efs</span> = <span class="keyword">Self</span> &#123;</span><br><span class="line">                block_device,</span><br><span class="line">                inode_bitmap: Bitmap::<span class="title function_ invoke__">new</span>(<span class="number">1</span>, super_block.inode_bitmap_blocks <span class="keyword">as</span> <span class="type">usize</span>),</span><br><span class="line">                data_bitmap: Bitmap::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                    (<span class="number">1</span> + inode_total_blocks) <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">                    super_block.data_bitmap_blocks <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">                ),</span><br><span class="line">                inode_area_start_block: <span class="number">1</span> + super_block.inode_bitmap_blocks,</span><br><span class="line">                data_area_start_block: <span class="number">1</span> + inode_total_blocks + super_block.data_bitmap_blocks,</span><br><span class="line">            &#125;;</span><br><span class="line">            Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(efs))</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  我们知道需要通过SuperBlock来初始化EasyFileSystem，而SuperBlock是放在块0中的，所以我们需要通过get_block_cache来读取块0，然后通过read方法读取块0中的SuperBlock。</p>
</li>
<li><p>使用文件系统</p>
<ul>
<li><p>封装Inode<br>  为了更好使用Inode，将其封装OSInode</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/fs/inode.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">OSInode</span> &#123;</span><br><span class="line">    readable: <span class="type">bool</span>,</span><br><span class="line">    writable: <span class="type">bool</span>,</span><br><span class="line">    inner: UPSafeCell&lt;OSInodeInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">OSInodeInner</span> &#123;</span><br><span class="line">    offset: <span class="type">usize</span>,</span><br><span class="line">    inode: Arc&lt;Inode&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  并为其实现File Trait</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">File</span> <span class="keyword">for</span> <span class="title class_">OSInode</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">readable</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.readable</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">writable</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.writable</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">read</span>(&amp;<span class="keyword">self</span>, <span class="keyword">mut</span> buf: UserBuffer) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total_read_size</span> = <span class="number">0usize</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">slice</span> <span class="keyword">in</span> buf.buffers.<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">read_size</span> = inner.inode.<span class="title function_ invoke__">read_at</span>(inner.offset, *slice);</span><br><span class="line">            <span class="keyword">if</span> read_size == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            inner.offset += read_size;</span><br><span class="line">            total_read_size += read_size;</span><br><span class="line">        &#125;</span><br><span class="line">        total_read_size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>, <span class="keyword">mut</span> buf: UserBuffer) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total_write_size</span> = <span class="number">0usize</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">slice</span> <span class="keyword">in</span> buf.buffers.<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">write_size</span> = inner.inode.<span class="title function_ invoke__">write_at</span>(inner.offset, *slice);</span><br><span class="line">            <span class="built_in">assert_eq!</span>(write_size, slice.<span class="title function_ invoke__">len</span>());</span><br><span class="line">            inner.offset += write_size;</span><br><span class="line">            total_write_size += write_size;</span><br><span class="line">        &#125;</span><br><span class="line">        total_write_size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fstat</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Stat &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">        inner.inode.<span class="title function_ invoke__">get_block_id</span>()</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">inode_id</span>;</span><br><span class="line">        Stat &#123;</span><br><span class="line">            dev: <span class="number">0</span>,</span><br><span class="line">            ino: inode_id,</span><br><span class="line">            mode: (),</span><br><span class="line">            nlink: (),</span><br><span class="line">            pad: (),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  read和write的实现也比较简单，拿到OSInodeInner，然后调用Inode的read_at和write_at方法即可。</p>
</li>
<li><p>操作文件系统<br>  对文件系统操作有很多比如打开文件，创建文件等，主要都通过Inode提供对应方法来操作。以下以打开文件为例：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">open_file</span>(name: &amp;<span class="type">str</span>, flags: OpenFlags) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;OSInode&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> (readable, writable) = flags.<span class="title function_ invoke__">read_write</span>();</span><br><span class="line">    <span class="keyword">if</span> flags.<span class="title function_ invoke__">contains</span>(OpenFlags::CREATE) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(inode) = ROOT_INODE.<span class="title function_ invoke__">find</span>(name) &#123;</span><br><span class="line">            <span class="comment">// clear size</span></span><br><span class="line">            inode.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(OSInode::<span class="title function_ invoke__">new</span>(readable, writable, inode)))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// create file</span></span><br><span class="line">            ROOT_INODE</span><br><span class="line">                .<span class="title function_ invoke__">create</span>(name)</span><br><span class="line">                .<span class="title function_ invoke__">map</span>(|inode| Arc::<span class="title function_ invoke__">new</span>(OSInode::<span class="title function_ invoke__">new</span>(readable, writable, inode)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ROOT_INODE.<span class="title function_ invoke__">find</span>(name).<span class="title function_ invoke__">map</span>(|inode| &#123;</span><br><span class="line">            <span class="keyword">if</span> flags.<span class="title function_ invoke__">contains</span>(OpenFlags::TRUNC) &#123;</span><br><span class="line">                inode.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            Arc::<span class="title function_ invoke__">new</span>(OSInode::<span class="title function_ invoke__">new</span>(readable, writable, inode))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  通过Inode::find找对应文件，Inode::create创建文件。</p>
</li>
</ul>
</li>
</ul>
<h1 id="内部实现方向"><a href="#内部实现方向" class="headerlink" title="内部实现方向"></a>内部实现方向</h1><p>这里我先换个方法，从最底层开始思考，看看是如何实现文件系统的。</p>
<h2 id="文件在磁盘上的形式"><a href="#文件在磁盘上的形式" class="headerlink" title="文件在磁盘上的形式"></a>文件在磁盘上的形式</h2><p>文件系统API部分我们知道整个文件系统分成5部分<br>| super block | inode_bitmap | inode_area | data_bitmap | data_area |<br>也应该明白，文件中的数据是放在data_area中的，为了标记数据是属于哪个文件的，我们就需要索引DiskInode。</p>
<h3 id="DiskInode"><a href="#DiskInode" class="headerlink" title="DiskInode"></a>DiskInode</h3><ol>
<li><p>定义</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">DiskInode</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> size: <span class="type">u32</span>,                          <span class="comment">// 文件大小</span></span><br><span class="line">    <span class="keyword">pub</span> direct: [<span class="type">u32</span>; INODE_DIRECT_COUNT],  <span class="comment">// 直接索引</span></span><br><span class="line">    <span class="keyword">pub</span> indirect1: <span class="type">u32</span>,                     <span class="comment">// 一级索引</span></span><br><span class="line">    <span class="keyword">pub</span> indirect2: <span class="type">u32</span>,                     <span class="comment">// 二级索引</span></span><br><span class="line">    type_: DiskInodeType,                   <span class="comment">// 文件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当 size&lt;&#x3D;14KB时，直接索引，此时DiskInode对应的data_area全是文件数据，内部块ID[0,28)<br> 当 14KB&lt; size &lt; 78KB时，使用了一级索引，此时data_area中会增加一个块来存储一级索引，内部块ID[28, 28 + 128)<br> 当 size &gt; 78KB时，使用了二级索引，此时data_area会在上面的基础上，再增加一块二级索引块，之后根据二级索引块中使用情况增加对等一级索引块，内部块ID[156, 156 + 128*128)</p>
<p> 所有的DiskInode依次放在inode_area中。<br> 对于文件来说，data_area存放文件数据，即DataBlock</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">DataBlock</span> = [<span class="type">u8</span>; BLOCK_SZ];</span><br></pre></td></tr></table></figure>
<p> 对于目录来说，没有文件数据，但是我们需要记录目录下的文件，所有我们就有了DirEntry</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A directory entry</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">DirEntry</span> &#123;</span><br><span class="line">    name: [<span class="type">u8</span>; NAME_LENGTH_LIMIT + <span class="number">1</span>],</span><br><span class="line">    inode_id: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 一个name用来存储文件名，一个inode_id用来存储文件的inode_id。<br> 一个目录下可能有多个文件，每个文件对应一个目录项，一次存放在目录的data_area中。</p>
</li>
<li><p>创建DiskInode</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">new_inode_id</span> = fs.<span class="title function_ invoke__">alloc_inode</span>();</span><br><span class="line"><span class="comment">// initialize inode</span></span><br><span class="line"><span class="keyword">let</span> (new_inode_block_id, new_inode_block_offset) = fs.<span class="title function_ invoke__">get_disk_inode_pos</span>(new_inode_id);</span><br><span class="line"><span class="title function_ invoke__">get_block_cache</span>(new_inode_block_id <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(&amp;<span class="keyword">self</span>.block_device))</span><br><span class="line">    .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">    .<span class="title function_ invoke__">modify</span>(new_inode_block_offset, |new_inode: &amp;<span class="keyword">mut</span> DiskInode| &#123;</span><br><span class="line">        new_inode.<span class="title function_ invoke__">initialize</span>(DiskInodeType::File);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>分配一个inode_id，通过Bitmap::alloc</li>
<li>通过inode_id找到inode_area中的block_id和offset</li>
<li>将DiskInode写入block_id中的offset位置</li>
</ul>
</li>
<li><p>文件扩容</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">increase_size</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    new_size: <span class="type">u32</span>,</span><br><span class="line">    new_blocks: <span class="type">Vec</span>&lt;<span class="type">u32</span>&gt;,</span><br><span class="line">    block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">current_blocks</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">data_blocks</span>();</span><br><span class="line">    <span class="keyword">self</span>.size = new_size;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total_blocks</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">data_blocks</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">new_blocks</span> = new_blocks.<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line">    <span class="comment">// fill direct</span></span><br><span class="line">    <span class="keyword">while</span> current_blocks &lt; total_blocks.<span class="title function_ invoke__">min</span>(INODE_DIRECT_COUNT <span class="keyword">as</span> <span class="type">u32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.direct[current_blocks <span class="keyword">as</span> <span class="type">usize</span>] = new_blocks.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        current_blocks += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// alloc indirect1</span></span><br><span class="line">    <span class="keyword">if</span> total_blocks &gt; INODE_DIRECT_COUNT <span class="keyword">as</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current_blocks == INODE_DIRECT_COUNT <span class="keyword">as</span> <span class="type">u32</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.indirect1 = new_blocks.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        current_blocks -= INODE_DIRECT_COUNT <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line">        total_blocks -= INODE_DIRECT_COUNT <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fill indirect1</span></span><br><span class="line">    <span class="title function_ invoke__">get_block_cache</span>(<span class="keyword">self</span>.indirect1 <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(block_device))</span><br><span class="line">        .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">        .<span class="title function_ invoke__">modify</span>(<span class="number">0</span>, |indirect1: &amp;<span class="keyword">mut</span> IndirectBlock| &#123;</span><br><span class="line">            <span class="keyword">while</span> current_blocks &lt; total_blocks.<span class="title function_ invoke__">min</span>(INODE_INDIRECT1_COUNT <span class="keyword">as</span> <span class="type">u32</span>) &#123;</span><br><span class="line">                indirect1[current_blocks <span class="keyword">as</span> <span class="type">usize</span>] = new_blocks.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                current_blocks += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">// alloc indirect2</span></span><br><span class="line">    <span class="keyword">if</span> total_blocks &gt; INODE_INDIRECT1_COUNT <span class="keyword">as</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current_blocks == INODE_INDIRECT1_COUNT <span class="keyword">as</span> <span class="type">u32</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.indirect2 = new_blocks.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        current_blocks -= INODE_INDIRECT1_COUNT <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line">        total_blocks -= INODE_INDIRECT1_COUNT <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fill indirect2 from (a0, b0) -&gt; (a1, b1)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a0</span> = current_blocks <span class="keyword">as</span> <span class="type">usize</span> / INODE_INDIRECT1_COUNT;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b0</span> = current_blocks <span class="keyword">as</span> <span class="type">usize</span> % INODE_INDIRECT1_COUNT;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a1</span> = total_blocks <span class="keyword">as</span> <span class="type">usize</span> / INODE_INDIRECT1_COUNT;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b1</span> = total_blocks <span class="keyword">as</span> <span class="type">usize</span> % INODE_INDIRECT1_COUNT;</span><br><span class="line">    <span class="comment">// alloc low-level indirect1</span></span><br><span class="line">    <span class="title function_ invoke__">get_block_cache</span>(<span class="keyword">self</span>.indirect2 <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(block_device))</span><br><span class="line">        .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">        .<span class="title function_ invoke__">modify</span>(<span class="number">0</span>, |indirect2: &amp;<span class="keyword">mut</span> IndirectBlock| &#123;</span><br><span class="line">            <span class="keyword">while</span> (a0 &lt; a1) || (a0 == a1 &amp;&amp; b0 &lt; b1) &#123;</span><br><span class="line">                <span class="keyword">if</span> b0 == <span class="number">0</span> &#123;</span><br><span class="line">                    indirect2[a0] = new_blocks.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// fill current</span></span><br><span class="line">                <span class="title function_ invoke__">get_block_cache</span>(indirect2[a0] <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(block_device))</span><br><span class="line">                    .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">                    .<span class="title function_ invoke__">modify</span>(<span class="number">0</span>, |indirect1: &amp;<span class="keyword">mut</span> IndirectBlock| &#123;</span><br><span class="line">                        indirect1[b0] = new_blocks.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                    &#125;);</span><br><span class="line">                <span class="comment">// move to next</span></span><br><span class="line">                b0 += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> b0 == INODE_INDIRECT1_COUNT &#123;</span><br><span class="line">                    b0 = <span class="number">0</span>;</span><br><span class="line">                    a0 += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 传入参数new_size为新文件大小，new_blocks为新分配的data_area中的块ID。<br> 这里假设我们之前文件大小为20个块，现在扩容到256个块（1个一级索引块，1个二级索引块，1个二级索引对应的1级索引块）</p>
<ul>
<li>最开始current_blocks为20，total_blocks为256，new_blocks[0;236)</li>
<li>填充直接索引，current_blocks为28，total_blocks为256，new_blocks[8,236)</li>
<li>填充一级索引，indirect1 &#x3D; 8, current_blocks置0，total_bloocks为256-28&#x3D;228，new_blocks[9,236)</li>
<li>填充一级索引块，不断从new_blocks中取出block_id写入索引块中，current_blocks为128，total_bloocks为228，new_blocks[137,236)</li>
<li>填充二级索引，indirect2 &#x3D; 137，current_blocks置0，total_blocks为228-128&#x3D;100，new_blocks[138,236)</li>
<li>填充二级索引块，从(0,0)到(0,100)，也是不断从new_blocks取出block_id，当开启新的一级索引块时，填充以下二级索引块，其他情况填充1级索引块</li>
</ul>
<p> 最终可以发现DiskInode在磁盘上布局<br> | file_data_0-27 | indirect1_0 | file_data_28_155 |indirect2 | indirect1_1 | file_data_156_283 |</p>
</li>
<li><p>访问文件数据<br> 我们有了DiskInode，现在需要访问文件数据的能力。<br> DiskInode的data_area流中，存在索引页，假设数据的内部下表[0,n)，<br> 我们需要一个函数，快捷返回对应block_id即get_block_id</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_block_id</span>(&amp;<span class="keyword">self</span>, inner_id: <span class="type">u32</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inner_id</span> = inner_id <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">if</span> inner_id &lt; INODE_DIRECT_COUNT &#123;</span><br><span class="line">        <span class="keyword">self</span>.direct[inner_id]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> inner_id &lt; INDIRECT1_BOUND &#123;</span><br><span class="line">        <span class="title function_ invoke__">get_block_cache</span>(<span class="keyword">self</span>.indirect1 <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(block_device))</span><br><span class="line">            .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">read</span>(<span class="number">0</span>, |indirect_block: &amp;IndirectBlock| &#123;</span><br><span class="line">                indirect_block[inner_id - INODE_DIRECT_COUNT]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">last</span> = inner_id - INDIRECT1_BOUND;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">indirect1</span> = <span class="title function_ invoke__">get_block_cache</span>(<span class="keyword">self</span>.indirect2 <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(block_device))</span><br><span class="line">            .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">read</span>(<span class="number">0</span>, |indirect2: &amp;IndirectBlock| &#123;</span><br><span class="line">                indirect2[last / INODE_INDIRECT1_COUNT]</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="title function_ invoke__">get_block_cache</span>(indirect1 <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(block_device))</span><br><span class="line">            .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">read</span>(<span class="number">0</span>, |indirect1: &amp;IndirectBlock| &#123;</span><br><span class="line">                indirect1[last % INODE_INDIRECT1_COUNT]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 流程如下：<br> - 如果inner_id小于direct，直接返回direct[inner_id]<br> - 如果inner_id处于一级索引中，读取indirect1中一级索引页的内容indreict_block，那么block_id即indirect_block[inner_id-28]<br> - 如果inner_id处于二级索引中，将inner_id减去156为last<br> 读取indirect2中的二级索引页，目标block_id即(last &#x2F; 128, last % 128)处<br> 那么访问文件数据如下，以读文件为例：</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">read_at</span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    offset: <span class="type">usize</span>,</span><br><span class="line">    buf: &amp;<span class="keyword">mut</span> [<span class="type">u8</span>],</span><br><span class="line">    block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">start</span> = offset;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">end</span> = (offset + buf.<span class="title function_ invoke__">len</span>()).<span class="title function_ invoke__">min</span>(<span class="keyword">self</span>.size <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">start_block</span> = start / BLOCK_SZ;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">read_size</span> = <span class="number">0usize</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// calculate end of current block</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">end_current_block</span> = (start / BLOCK_SZ + <span class="number">1</span>) * BLOCK_SZ;</span><br><span class="line">        end_current_block = end_current_block.<span class="title function_ invoke__">min</span>(end);</span><br><span class="line">        <span class="comment">// read and update read size</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">block_read_size</span> = end_current_block - start;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">dst</span> = &amp;<span class="keyword">mut</span> buf[read_size..read_size + block_read_size];</span><br><span class="line">        <span class="title function_ invoke__">get_block_cache</span>(</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">get_block_id</span>(start_block <span class="keyword">as</span> <span class="type">u32</span>, block_device) <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">            Arc::<span class="title function_ invoke__">clone</span>(block_device),</span><br><span class="line">        )</span><br><span class="line">        .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read</span>(<span class="number">0</span>, |data_block: &amp;DataBlock| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">src</span> = &amp;data_block[start % BLOCK_SZ..start % BLOCK_SZ + block_read_size];</span><br><span class="line">            dst.<span class="title function_ invoke__">copy_from_slice</span>(src);</span><br><span class="line">        &#125;);</span><br><span class="line">        read_size += block_read_size;</span><br><span class="line">        <span class="comment">// move to next block</span></span><br><span class="line">        <span class="keyword">if</span> end_current_block == end &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start_block += <span class="number">1</span>;</span><br><span class="line">        start = end_current_block;</span><br><span class="line">    &#125;</span><br><span class="line">    read_size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 参数分析：<br> offset：相对于DiskInode的偏移量<br> buf：缓冲区，存放读取数据，读取最多buf.len()个字节<br> block_device：块设备，用来访问文件数据<br> 返回值：读取的字节数<br> offset基本可以与外部统一为文件的偏移量，<br> 先根据文件大小与缓冲区长度确定读取范围，即读取[offset,end)<br> 然后从offset&#x2F;BLOCK_SZ start_block开始<br> 通过get_block_id()拿到start_block的真正block_id，<br> 然后读取对应DataBlock，通过copy_from_slice到buf<br> 然后start_block+1，读取下块<br> 这个通过一个块一个块读取，跳过了对应的索引页</p>
</li>
</ol>
<h2 id="外部世界与文件桥梁"><a href="#外部世界与文件桥梁" class="headerlink" title="外部世界与文件桥梁"></a>外部世界与文件桥梁</h2><p>之前我们以API的角度来分析了Inode，现在我们以文件系统内部视角来分析Inode。<br>Inode处于文件系统API层，用来封装DiskInode，提供更方便的访问文件数据的能力。</p>
<ol>
<li><p>定义</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Inode</span> &#123;</span><br><span class="line">    block_id: <span class="type">usize</span>,</span><br><span class="line">    block_offset: <span class="type">usize</span>,</span><br><span class="line">    fs: Arc&lt;Mutex&lt;EasyFileSystem&gt;&gt;,</span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Inode是一个DiskInode的封装，如何索引DiskInode，通过块ID加上块内offset即可索引到对应DiskInode。<br> 为了方便通过block_id，block_offset操作DiskInode，增加两个内部方法</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Call a function over a disk inode to read it</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_disk_inode</span>&lt;V&gt;(&amp;<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="title class_">FnOnce</span>(&amp;DiskInode) <span class="punctuation">-&gt;</span> V) <span class="punctuation">-&gt;</span> V &#123;</span><br><span class="line">    <span class="title function_ invoke__">get_block_cache</span>(<span class="keyword">self</span>.block_id, Arc::<span class="title function_ invoke__">clone</span>(&amp;<span class="keyword">self</span>.block_device))</span><br><span class="line">        .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read</span>(<span class="keyword">self</span>.block_offset, f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Call a function over a disk inode to modify it</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">modify_disk_inode</span>&lt;V&gt;(&amp;<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="title class_">FnOnce</span>(&amp;<span class="keyword">mut</span> DiskInode) <span class="punctuation">-&gt;</span> V) <span class="punctuation">-&gt;</span> V &#123;</span><br><span class="line">    <span class="title function_ invoke__">get_block_cache</span>(<span class="keyword">self</span>.block_id, Arc::<span class="title function_ invoke__">clone</span>(&amp;<span class="keyword">self</span>.block_device))</span><br><span class="line">        .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">        .<span class="title function_ invoke__">modify</span>(<span class="keyword">self</span>.block_offset, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Inode</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Create inode under current inode by name</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">create</span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;Inode&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fs</span> = <span class="keyword">self</span>.fs.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">op</span> = |root_inode: &amp;DiskInode| &#123;</span><br><span class="line">        <span class="comment">// assert it is a directory</span></span><br><span class="line">        <span class="built_in">assert!</span>(root_inode.<span class="title function_ invoke__">is_dir</span>());</span><br><span class="line">        <span class="comment">// has the file been created?</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">find_inode_id</span>(name, root_inode)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">read_disk_inode</span>(op).<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// create a new file</span></span><br><span class="line">    <span class="comment">// alloc a inode with an indirect block</span></span><br><span class="line">    <span class="comment">/// 创建DiskInode</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_inode_id</span> = fs.<span class="title function_ invoke__">alloc_inode</span>();</span><br><span class="line">    <span class="comment">// initialize inode</span></span><br><span class="line">    <span class="keyword">let</span> (new_inode_block_id, new_inode_block_offset) = fs.<span class="title function_ invoke__">get_disk_inode_pos</span>(new_inode_id);</span><br><span class="line">    <span class="title function_ invoke__">get_block_cache</span>(new_inode_block_id <span class="keyword">as</span> <span class="type">usize</span>, Arc::<span class="title function_ invoke__">clone</span>(&amp;<span class="keyword">self</span>.block_device))</span><br><span class="line">        .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">        .<span class="title function_ invoke__">modify</span>(new_inode_block_offset, |new_inode: &amp;<span class="keyword">mut</span> DiskInode| &#123;</span><br><span class="line">            new_inode.<span class="title function_ invoke__">initialize</span>(DiskInodeType::File);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 增加目录项</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">modify_disk_inode</span>(|root_inode| &#123;</span><br><span class="line">        <span class="comment">// append file in the dirent</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">file_count</span> = (root_inode.size <span class="keyword">as</span> <span class="type">usize</span>) / DIRENT_SZ;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">new_size</span> = (file_count + <span class="number">1</span>) * DIRENT_SZ;</span><br><span class="line">        <span class="comment">// increase size</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">increase_size</span>(new_size <span class="keyword">as</span> <span class="type">u32</span>, root_inode, &amp;<span class="keyword">mut</span> fs);</span><br><span class="line">        <span class="comment">// write dirent</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">dirent</span> = DirEntry::<span class="title function_ invoke__">new</span>(name, new_inode_id);</span><br><span class="line">        root_inode.<span class="title function_ invoke__">write_at</span>(</span><br><span class="line">            file_count * DIRENT_SZ,</span><br><span class="line">            dirent.<span class="title function_ invoke__">as_bytes</span>(),</span><br><span class="line">            &amp;<span class="keyword">self</span>.block_device,</span><br><span class="line">        );</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (block_id, block_offset) = fs.<span class="title function_ invoke__">get_disk_inode_pos</span>(new_inode_id);</span><br><span class="line">    <span class="title function_ invoke__">block_cache_sync_all</span>();</span><br><span class="line">    <span class="comment">// return inode</span></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">new</span>(<span class="keyword">Self</span>::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        block_id,</span><br><span class="line">        block_offset,</span><br><span class="line">        <span class="keyword">self</span>.fs.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        <span class="keyword">self</span>.block_device.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    )))</span><br><span class="line">    <span class="comment">// release efs lock automatically by compiler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 参数分析：</p>
<ul>
<li>name：文件名</li>
<li>返回值：创建的文件的Inode<br> 首先检查是否目录，是否已有相同名称文件。<br> 接着创建DiskInode<br> 通过modify_disk_inode写入目录项，写入时要先扩容DiskInode，在写入目录项<br> block_cache_sync_all同步块缓存，返回Inode</li>
</ul>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://rubick-hqm.github.io/2025/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" data-id="cm9wq95tc0001z8vja8yfhe52" data-title="操作系统_文件系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统_进程及进程管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2025-04-16T08:33:02.657Z" itemprop="datePublished">2025-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">操作系统_进程及进程管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>以下是参加清华大学2025 春夏季开源操作系统训练营CH5的学习blog。<br>本节关于操作系统的进程及进程管理<br>主要内容有：</p>
<ol>
<li>进程抽象，即进程描述符的创建，销毁等</li>
<li>进程管理，操作系统的进程调度相关</li>
</ol>
<h1 id="1-进程描述符"><a href="#1-进程描述符" class="headerlink" title="1. 进程描述符"></a>1. 进程描述符</h1><h2 id="1-1-进程描述符定义"><a href="#1-1-进程描述符定义" class="headerlink" title="1.1 进程描述符定义"></a>1.1 进程描述符定义</h2><p>先给定进程描述符的定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlock</span> &#123;</span><br><span class="line">    <span class="comment">// Immutable</span></span><br><span class="line">    <span class="comment">/// Process identifier</span></span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Kernel stack corresponding to PID</span></span><br><span class="line">    <span class="keyword">pub</span> kernel_stack: KernelStack,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Mutable</span></span><br><span class="line">    inner: UPSafeCell&lt;TaskControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先定义了进程描述符</p>
<ul>
<li>pid：进程唯一标识</li>
<li>kernel_stack：进程内核栈，内核栈被分配在内核地址空间的跳板下的页上</li>
</ul>
<p>inner是一些可变字段</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlockInner</span> &#123;</span><br><span class="line">    <span class="comment">// 仅展示一些重要字段</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="keyword">pub</span> memory_set: MemorySet,</span><br><span class="line">    <span class="keyword">pub</span> parent: <span class="type">Option</span>&lt;Weak&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> children: <span class="type">Vec</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>task_cx: 进程上下文，用于进程切换时上下文的保存</li>
<li>task_status: 进程状态</li>
<li>memory_set: 进程地址空间</li>
<li>parent: 父进程，使用弱引用指向</li>
<li>children：子进程</li>
<li>exit_code: 进程退出码，提供给父进程使用</li>
</ul>
<h2 id="1-2-进程描述符创建"><a href="#1-2-进程描述符创建" class="headerlink" title="1.2 进程描述符创建"></a>1.2 进程描述符创建</h2><p>先提供创建代码：</p>
<figure class="highlight rust"><figcaption><span>linenos</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(elf_data: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> (memory_set, user_sp, entry_point) = MemorySet::<span class="title function_ invoke__">from_elf</span>(elf_data);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pid_handle</span> = <span class="title function_ invoke__">pid_alloc</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">kernel_stack</span> = <span class="title function_ invoke__">kstack_alloc</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">kernel_stack_top</span> = kernel_stack.<span class="title function_ invoke__">get_top</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task_control_block</span> = <span class="keyword">Self</span> &#123;</span><br><span class="line">        pid: pid_handle,</span><br><span class="line">        kernel_stack,</span><br><span class="line">        inner: <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            UPSafeCell::<span class="title function_ invoke__">new</span>(TaskControlBlockInner &#123;</span><br><span class="line">                task_cx: TaskContext::<span class="title function_ invoke__">goto_trap_return</span>(kernel_stack_top),</span><br><span class="line">                task_status: TaskStatus::Ready,</span><br><span class="line">                memory_set,</span><br><span class="line">                parent: <span class="literal">None</span>,</span><br><span class="line">                children: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                exit_code: <span class="number">0</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// prepare TrapContext in user space</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx</span> = task_control_block.<span class="title function_ invoke__">inner_exclusive_access</span>().<span class="title function_ invoke__">get_trap_cx</span>();</span><br><span class="line">    *trap_cx = TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">        entry_point,</span><br><span class="line">        user_sp,</span><br><span class="line">        KERNEL_SPACE.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">token</span>(),</span><br><span class="line">        kernel_stack_top,</span><br><span class="line">        trap_handler <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">    );</span><br><span class="line">    task_control_block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过elf_data创建进程地址空间，这个指路内存管理</li>
<li>分配pid</li>
<li>分配内核栈</li>
<li>进程的上下文先通过goto_trap_return初始化</li>
<li>通过TrapContext::app_init_context</li>
</ol>
<h1 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2. 进程管理"></a>2. 进程管理</h1><h2 id="2-1-进程管理器"><a href="#2-1-进程管理器" class="headerlink" title="2.1 进程管理器"></a>2.1 进程管理器</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line">    ready_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, task: Arc&lt;TaskControlBlock&gt;);</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fetch</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TaskManager仅有一个FIFO队列，用于存放就绪的进程，提供两个方法，add和fetch，分别用于添加进程和获取进程，这里简单为添加到队尾，取出队首。</p>
<h2 id="2-2-处理器"><a href="#2-2-处理器" class="headerlink" title="2.2 处理器"></a>2.2 处理器</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">    current: <span class="type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">    idle_task_cx: TaskContext,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Processor两个字段，current表示当前正在执行的进程，idle_task_cx表示空闲流<br>processor作用就是调度进程，从当前任务执行切换到idle流</p>
<figure class="highlight rust"><figcaption><span>linenos</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run_tasks</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">processor</span> = PROCESSOR.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = <span class="title function_ invoke__">fetch_task</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">idle_task_cx_ptr</span> = processor.<span class="title function_ invoke__">get_idle_task_cx_ptr</span>();</span><br><span class="line">            <span class="comment">// access coming task TCB exclusively</span></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">task_inner</span> = task.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">next_task_cx_ptr</span> = &amp;task_inner.task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line">            task_inner.task_status = TaskStatus::Running;</span><br><span class="line">            <span class="comment">// release coming task_inner manually</span></span><br><span class="line">            <span class="title function_ invoke__">drop</span>(task_inner);</span><br><span class="line">            <span class="comment">// release coming task TCB manually</span></span><br><span class="line">            processor.current = <span class="title function_ invoke__">Some</span>(task);</span><br><span class="line">            <span class="comment">// release processor manually</span></span><br><span class="line">            <span class="title function_ invoke__">drop</span>(processor);</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                __switch(idle_task_cx_ptr, next_task_cx_ptr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            warn!(<span class="string">&quot;no tasks available in run_tasks&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>idle流这个流程即从task_manager取出进程，修改状态运行，保存到current，然后通过__switch切换到当前任务</p>
<figure class="highlight rust"><figcaption><span>linenos</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">schedule</span>(switched_task_cx_ptr: *<span class="keyword">mut</span> TaskContext) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">processor</span> = PROCESSOR.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">idle_task_cx_ptr</span> = processor.<span class="title function_ invoke__">get_idle_task_cx_ptr</span>();</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(processor);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __switch(switched_task_cx_ptr, idle_task_cx_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从current_task切换回idle_task通过调度，这里__switch会回到run_tasks的__switch出，也就继续取出下一个进程</p>
<h2 id="2-3-用户态进程创建"><a href="#2-3-用户态进程创建" class="headerlink" title="2.3 用户态进程创建"></a>2.3 用户态进程创建</h2><p>我们需要给用户态提供创建进程能力，这里就是多个相关syscall</p>
<h3 id="sys-fork"><a href="#sys-fork" class="headerlink" title="sys_fork"></a>sys_fork</h3><p>从当前进程创建出一个子进程。我们知道TCB即进程抽象，所以就是从当前进程的TCB创建出一个新的TCB。步骤如下：</p>
<ol>
<li>创建新的内存地址空间</li>
<li>分配新pid，kernel_stack</li>
<li>重新设置用户地址空间高256G的映射（包括跳板以及trap_context)<br>创建了新的TCB之后，我们将其加入上面的就绪队列，等待调度</li>
</ol>
<h3 id="sys-exec"><a href="#sys-exec" class="headerlink" title="sys_exec"></a>sys_exec</h3><p>执行给定的elf文件。不同与fork，这里我们需要将创建的新用户地址空间替换原来的，使用原来的pid和kernel_stack，并调整trap_context指向新程序</p>
<h3 id="sys-waitpid"><a href="#sys-waitpid" class="headerlink" title="sys_waitpid"></a>sys_waitpid</h3><p>因为实现细节不同不细分析，基本就是找到对应子进程，从children移除引用，返回退出码</p>
<h2 id="2-4-init进程"><a href="#2-4-init进程" class="headerlink" title="2.4 init进程"></a>2.4 init进程</h2><p>我们知道linux内核启动后会创建init进程，这个进程是所有进程的父进程。<br>本次实验中也有这么一个Init进程，它全局变量的方式创建在rss区</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="comment">/// initproc的task control block</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> INITPROC: Arc&lt;TaskControlBlock&gt; = Arc::<span class="title function_ invoke__">new</span>(TaskControlBlock::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        <span class="title function_ invoke__">get_app_data_by_name</span>(<span class="string">&quot;ch5b_initproc&quot;</span>).<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内核初始化时通过add_task加入TaskManager就绪队列，等待调度。<br>用户程序exit退出后，进程资源回收就是通过Init进程。<br>用户程序退出后将自己状态改为zombie等待init回收，同时遍历自己的子进程，将其托管给init进程（即父进程改为init，init进程children列表增加），回收用户程序的内存地址。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exit_current_and_run_next</span>(exit_code: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task</span> = <span class="title function_ invoke__">take_current_task</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// 当前为INITPROC，直接退出</span></span><br><span class="line">    <span class="keyword">if</span> task.<span class="title function_ invoke__">get_pid</span>() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = task.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    inner.task_status = TaskStatus::Zombie;</span><br><span class="line">    inner.exit_code = exit_code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将此任务的所有儿子都托管给initproc</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">initproc_inner</span> = INITPROC.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">        inner.children.<span class="title function_ invoke__">iter</span>().for_each(|child| &#123;</span><br><span class="line">            child.<span class="title function_ invoke__">inner_exclusive_access</span>().parent = <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">downgrade</span>(&amp;INITPROC));</span><br><span class="line">            initproc_inner.children.<span class="title function_ invoke__">push</span>(Arc::<span class="title function_ invoke__">clone</span>(child));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inner.children.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">    <span class="comment">// 回收当前任务的数据页</span></span><br><span class="line">    inner.memory_set.<span class="title function_ invoke__">recycle_data_pages</span>();</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(inner);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行下一个任务</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">_unused</span> = TaskContext::<span class="title function_ invoke__">zero_init</span>();</span><br><span class="line">    <span class="title function_ invoke__">schedule</span>(&amp;<span class="keyword">mut</span> _unused <span class="keyword">as</span> *<span class="keyword">mut</span> _);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-进程的生命周期管理"><a href="#3-进程的生命周期管理" class="headerlink" title="3. 进程的生命周期管理"></a>3. 进程的生命周期管理</h1><p>这里我想讨论TCB的生命周期管理，也就是<code>Arc&lt;TaskControlBlock&gt;</code>的引用，哪些时间点被哪些数据结构持有。</p>
<ul>
<li>用户进程创建<br>  用户一般通过sys_fork+sys_exec创建新进程，那么init_proc.children中有TCB的引用，sys_exec执行后会将TCB加入TaskManager.ready_queue，这是第二个引用。<br>  此时两个引用：<br>  {INIT_PROC.children, TASK_MANGER.ready_queue}</li>
<li>调度<br>  调度时，通过TaskManager::fetch()拿到TCB所有权，并将其放入Processor.current字段中。<br>  此时两个引用：<br>  {INIT_PROC.children, PROCESSOR.current}</li>
<li>进程退出<br>  用户调用exit后，使用take_current_task()从PROCESSOR.current获得所有权，并将其释放drop。<br>  此时一个引用：<br>  {INIT_PROC.children}</li>
<li>回收<br>  waitpid中最终将TCB从INIT_PROC.children中移除。至此TCB引用为0，被最终释放。</li>
</ul>
<h1 id="4-章节总结"><a href="#4-章节总结" class="headerlink" title="4. 章节总结"></a>4. 章节总结</h1><p>本章抽象出了进程概念，完善了TaskControlBlock。<br>并将之前的任务切换等分成TaskManger任务管理器和Processor处理器，<br>TaskManager负责任务队列，Processor负责任务调度切换，使各自模块更清晰。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rubick-hqm.github.io/2025/04/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" data-id="cm9wq95td0002z8vj734p9arc" data-title="操作系统_进程及进程管理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-serde" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/02/serde/" class="article-date">
  <time class="dt-published" datetime="2025-03-02T07:21:08.436Z" itemprop="datePublished">2025-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/02/serde/">serde的使用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>以下均为个人理解。</p>
<p>serde是rust中一个流行的序列化和反序列解决方案库。通过trait的方式，定义了一种序列化和反序列化的通用方法来实现这一过程。而实际应用，需要另外的运行库，类似rust本身定义了future，但是真正跑起来需要tokio等runtime。这里就比如serde_json这种真正的协议库。</p>
<h2 id="serde数据模型"><a href="#serde数据模型" class="headerlink" title="serde数据模型"></a>serde数据模型</h2><p>serde将rust中的类型分成一下几类</p>
<ul>
<li>bool</li>
<li>i8,i16,i32,i64,i128</li>
<li>u8,u16,u32,u64,u128</li>
<li>f32,f64</li>
<li>char, str, bytes</li>
<li>option</li>
<li>seq</li>
<li>unit</li>
<li>struct, unit_struct, newtype_struct, tuple_struct</li>
<li>map</li>
<li>variant, newtype_variant, unit_variant, struct_variant, tuple_struct</li>
</ul>
<p>将rust中的各种类型映射到上述类型中，调用对应的序列化或反序列化函数。</p>
<h2 id="序列化-serialize"><a href="#序列化-serialize" class="headerlink" title="序列化 serialize"></a>序列化 serialize</h2><p>一个可能的调用序列化的例子如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    a: <span class="type">i32</span>,</span><br><span class="line">    b: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Serialize</span> <span class="keyword">for</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">serialize</span>&lt;S&gt;(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        serializer: S,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;S::<span class="literal">Ok</span>, S::Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        S: Serializer,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">state</span> =</span><br><span class="line">            serializer.<span class="title function_ invoke__">serialize_struct</span>(<span class="string">&quot;Test&quot;</span>, <span class="number">2</span>)?;</span><br><span class="line">        state.<span class="title function_ invoke__">serialize_field</span>(<span class="string">&quot;a&quot;</span>, &amp;<span class="keyword">self</span>.a)?;</span><br><span class="line">        state.<span class="title function_ invoke__">serialize_field</span>(<span class="string">&quot;b&quot;</span>, &amp;<span class="keyword">self</span>.b)?;</span><br><span class="line">        state.<span class="title function_ invoke__">end</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>serde将序列化的方式分为两步，第一步是创建一个序列化器，第二步是调用序列化器的序列化函数。<br>第二步调用序列化器的序列化函数是可以通过derive宏自动生成的。<br>那么第一步如何创建一个序列化器呢？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Serializer</span>: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Ok</span>;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span>: Error;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">SerializeSeq</span>: SerializeSeq&lt;<span class="literal">Ok</span> = <span class="keyword">Self</span>::<span class="literal">Ok</span>, Error = <span class="keyword">Self</span>::Error&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">SerializeTuple</span>: SerializeTuple&lt;<span class="literal">Ok</span> = <span class="keyword">Self</span>::<span class="literal">Ok</span>, Error = <span class="keyword">Self</span>::Error&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">SerializeTupleStruct</span>: SerializeTupleStruct&lt;<span class="literal">Ok</span> = <span class="keyword">Self</span>::<span class="literal">Ok</span>, Error = <span class="keyword">Self</span>::Error&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">SerializeTupleVariant</span>: SerializeTupleVariant&lt;<span class="literal">Ok</span> = <span class="keyword">Self</span>::<span class="literal">Ok</span>, Error = <span class="keyword">Self</span>::Error&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">SerializeMap</span>: SerializeMap&lt;<span class="literal">Ok</span> = <span class="keyword">Self</span>::<span class="literal">Ok</span>, Error = <span class="keyword">Self</span>::Error&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">SerializeStruct</span>: SerializeStruct&lt;<span class="literal">Ok</span> = <span class="keyword">Self</span>::<span class="literal">Ok</span>, Error = <span class="keyword">Self</span>::Error&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">serialize_bool</span>(<span class="keyword">self</span>, v: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>::<span class="literal">Ok</span>, <span class="keyword">Self</span>::Error&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">serialize_i8</span>(<span class="keyword">self</span>, v: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>::<span class="literal">Ok</span>, <span class="keyword">Self</span>::Error&gt;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>serde中定义了一个序列化器接口，其中定义了各种序列化函数，而各种序列化函数对应了上述数据模型中的各种类型。<br>那么一个可能的序列化函数实现就如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">serialize_bool</span>(<span class="keyword">self</span>, v: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>::<span class="literal">Ok</span>, <span class="keyword">Self</span>::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.output.<span class="title function_ invoke__">extend_from_slice</span>(<span class="string">b&quot;i&quot;</span>);</span><br><span class="line">    <span class="keyword">self</span>.output.<span class="title function_ invoke__">append</span>(<span class="keyword">if</span> v &#123; <span class="string">b&quot;1&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">b&quot;0&quot;</span> &#125;);</span><br><span class="line">    <span class="keyword">self</span>.output.<span class="title function_ invoke__">extend_from_slice</span>(<span class="string">b&quot;e&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过不断调用序列化函数，最终就可以得到序列化后的数据，保存在Serializer。<br>回顾定义的Serializer中，有一些奇怪的类型，比如SerializeSeq, SerializeTuple, SerializeTupleStruct, SerializeTupleVariant, SerializeMap, SerializeStruct。<br>Seq, tuple, tuple_struct, tuple_variant, map, struct这些都是复合类型<br>以seq为例，切片比如[i8]，由多个i8类型组成<br>serde就将这些复合类型抽象出新的序列化器, 例如</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">SerializeSeq</span> &#123;</span><br><span class="line">    <span class="comment">/// Must match the `Ok` type of our `Serializer`.</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Ok</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Must match the `Error` type of our `Serializer`.</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span>: Error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Serialize a sequence element.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">serialize_element</span>&lt;T&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: &amp;T) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="keyword">Self</span>::Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        T: ?<span class="built_in">Sized</span> + Serialize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Finish serializing a sequence.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">end</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>::<span class="literal">Ok</span>, <span class="keyword">Self</span>::Error&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重复调用serialize_element，直到end结束。</p>
<h2 id="反序列化-deserialize"><a href="#反序列化-deserialize" class="headerlink" title="反序列化 deserialize"></a>反序列化 deserialize</h2><p>同样，一个可能的反序列化例子如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(PartialEq, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    a: <span class="type">i32</span>,</span><br><span class="line">    b: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;de</span>&gt; Deserialize&lt;<span class="symbol">&#x27;de</span>&gt; <span class="keyword">for</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deserialize</span>&lt;D&gt;(</span><br><span class="line">        deserializer: D,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>, D::Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        D: serde::Deserializer&lt;<span class="symbol">&#x27;de</span>&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Visitor</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">impl</span>&lt;<span class="symbol">&#x27;de</span>&gt; serde::de::Visitor&lt;<span class="symbol">&#x27;de</span>&gt; <span class="keyword">for</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">            <span class="keyword">type</span> <span class="title class_">Value</span> = Test;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">expecting</span>(</span><br><span class="line">                &amp;<span class="keyword">self</span>,</span><br><span class="line">                formatter: &amp;<span class="keyword">mut</span> std::fmt::Formatter,</span><br><span class="line">            ) <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span> &#123;</span><br><span class="line">                formatter.<span class="title function_ invoke__">write_str</span>(<span class="string">&quot;struct Test&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">visit_map</span>&lt;V&gt;(</span><br><span class="line">                <span class="keyword">self</span>,</span><br><span class="line">                <span class="keyword">mut</span> map: V,</span><br><span class="line">            ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>::Value, V::Error&gt;</span><br><span class="line">            <span class="keyword">where</span></span><br><span class="line">                V: serde::de::MapAccess&lt;<span class="symbol">&#x27;de</span>&gt;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="literal">None</span>;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(key) =</span><br><span class="line">                    map.next_key::&lt;<span class="type">String</span>&gt;()?</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">match</span> key.<span class="title function_ invoke__">as_str</span>() &#123;</span><br><span class="line">                        <span class="string">&quot;a&quot;</span> =&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> a.<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(</span><br><span class="line">                                    Error::<span class="title function_ invoke__">duplicate_field</span>(</span><br><span class="line">                                        <span class="string">&quot;a&quot;</span>,</span><br><span class="line">                                    ),</span><br><span class="line">                                );</span><br><span class="line">                            &#125;</span><br><span class="line">                            a = <span class="title function_ invoke__">Some</span>(map.<span class="title function_ invoke__">next_value</span>()?);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="string">&quot;b&quot;</span> =&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> b.<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(</span><br><span class="line">                                    Error::<span class="title function_ invoke__">duplicate_field</span>(</span><br><span class="line">                                        <span class="string">&quot;b&quot;</span>,</span><br><span class="line">                                    ),</span><br><span class="line">                                );</span><br><span class="line">                            &#125;</span><br><span class="line">                            b = <span class="title function_ invoke__">Some</span>(map.<span class="title function_ invoke__">next_value</span>()?);</span><br><span class="line">                        &#125;</span><br><span class="line">                        unknown =&gt; &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">unknown_field</span>(</span><br><span class="line">                                unknown,</span><br><span class="line">                                &amp;[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>],</span><br><span class="line">                            ))</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">a</span> = a.<span class="title function_ invoke__">ok_or_else</span>(|| &#123;</span><br><span class="line">                    Error::<span class="title function_ invoke__">missing_field</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">                &#125;)?;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">b</span> = b.<span class="title function_ invoke__">ok_or_else</span>(|| &#123;</span><br><span class="line">                    Error::<span class="title function_ invoke__">missing_field</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">                &#125;)?;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(Test &#123; a, b &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deserializer.<span class="title function_ invoke__">deserialize_struct</span>(</span><br><span class="line">                    <span class="string">&quot;Test&quot;</span>,</span><br><span class="line">                    &amp;[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>],</span><br><span class="line">                    Visitor,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子中，用户自定义了一个visitor，实现了visit_map方法，方法中通过不断next_key来推动解析，尝试获取到key后，在通过next_value来继续推动解析，直至最后解析玩整个类型Test<br>而整个解析流程的起点为deserializer的反序列化函数deserialize_struct</p>
<p>那么deserialize_struct函数又具体做了什么？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">deserialize_struct</span>&lt;V&gt;(</span><br><span class="line">    <span class="keyword">self</span>,</span><br><span class="line">    _name: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>,</span><br><span class="line">    _fields: &amp;<span class="symbol">&#x27;static</span> [&amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>],</span><br><span class="line">    visitor: V,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;V::Value&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    V: Visitor&lt;<span class="symbol">&#x27;de</span>&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">deserialize_map</span>(visitor)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deserialize_map</span>&lt;V&gt;(<span class="keyword">self</span>, visitor: V) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;V::Value&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    V: Visitor&lt;<span class="symbol">&#x27;de</span>&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">next_byte</span>().<span class="title function_ invoke__">unwrap</span>() == <span class="string">b&#x27;d&#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">value</span> =</span><br><span class="line">            visitor.<span class="title function_ invoke__">visit_map</span>(CommaMapAccess::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>))?;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">next_byte</span>().<span class="title function_ invoke__">unwrap</span>() == <span class="string">b&#x27;e&#x27;</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(Error::ExpectedEnd)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(Error::ExpectedMap)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述就是一个可能的反序列化函数实现。<br>本质上struct本身也是kv键值对形式，k只不过限制为了String而已，跟map相同实现<br>deserialize_map中即调用了用户定义的Visitor的visit_map方法。<br>而CommaMapAccess类似与序列化过程中的SerializeMap<br>Serde将一些复合类型抽象出对应Trait来方便处理，map对应MapAccess</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///  serde中trait定义</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">MapAccess</span>&lt;<span class="symbol">&#x27;de</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span>: Error;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next_key_seed</span>&lt;K&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, seed: K) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Option</span>&lt;K::Value&gt;, <span class="keyword">Self</span>::Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        K: DeserializeSeed&lt;<span class="symbol">&#x27;de</span>&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next_value_seed</span>&lt;V&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, seed: V) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;V::Value, <span class="keyword">Self</span>::Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        V: DeserializeSeed&lt;<span class="symbol">&#x27;de</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///   自定义的MapAccess实现</span></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;de</span>&gt; serde::de::MapAccess&lt;<span class="symbol">&#x27;de</span>&gt; <span class="keyword">for</span> <span class="title class_">CommaMapAccess</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;de</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span> = Error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next_key_seed</span>&lt;K&gt;(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        seed: K,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Option</span>&lt;K::Value&gt;&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        K: DeserializeSeed&lt;<span class="symbol">&#x27;de</span>&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.de.<span class="title function_ invoke__">peek_byte</span>().<span class="title function_ invoke__">unwrap</span>() == <span class="string">b&#x27;e&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(<span class="literal">None</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        seed.<span class="title function_ invoke__">deserialize</span>(&amp;<span class="keyword">mut</span> *<span class="keyword">self</span>.de).<span class="title function_ invoke__">map</span>(<span class="literal">Some</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next_value_seed</span>&lt;V&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, seed: V) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;V::Value&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        V: DeserializeSeed&lt;<span class="symbol">&#x27;de</span>&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        seed.<span class="title function_ invoke__">deserialize</span>(&amp;<span class="keyword">mut</span> *<span class="keyword">self</span>.de)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义的实现也非常简单，通过递归调用deserialize方法，来解析对应类型</p>
<p>反序列化总流程以struct Test为例</p>
<ol>
<li>调用反序列化器的deserialize_struct方法，进入流程</li>
<li>deserialize_struct中调用自定义visitor的visit_map方法，解析Test类型</li>
<li>visit_map中通过next_key来解析key，通过next_value来解析value</li>
<li>next_key和next_value中通过deserialize方法来递归解析对应类型key,value</li>
<li>解析完所有key,value后，返回解析结果</li>
</ol>
<h2 id="自定义协议库"><a href="#自定义协议库" class="headerlink" title="自定义协议库"></a>自定义协议库</h2><p>比较简单，按照给定协议形式，完成serializer和deserializer即可，具体可参考<a target="_blank" rel="noopener" href="https://serde.rs/impl-serializer.html">serializer</a>和<a target="_blank" rel="noopener" href="https://serde.rs/impl-deserializer.html">deserializer</a></p>
<p>讲一下我实现bencode协议库过程中踩的坑：</p>
<ol>
<li>字符串和二进制流<br> 在bencode协议中，字符串和二进制均以相同形式编码，即以字符串形式表示长度，然后以二进制形式表示内容，即3:abc<br> 但是rust中，字符串和二进制流是两种不同的类型，String 和 [u8]，而[u8]会被认为是seq而不是bytes_buf，所有我引入了serde_bytes来解析二进制流   <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Deserialize, Serialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="meta">#[serde(with = <span class="string">&quot;serde_bytes&quot;</span>)]</span></span><br><span class="line">    a: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>反序列中的歧义<br> 在实现反序列化器时，有个一个反序列化函数值得关注deserialize_any<br> 从命名来说，这个反序列化函数指不确定类型时调用<br> 那么对于bencode来说就有些许问题，比如rust类型中的bool和整型，字符串和二进制流，在bencode编码中均为相同序列化形式。<br> 所有我在实现deserialize_any时，将bencode整型解析成i64，所有字符串类型，先将其尝试转成String，失败则解析成二进制流 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">deserialize_any</span>&lt;V&gt;(<span class="keyword">self</span>, visitor: V) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;V::Value&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">V: Visitor&lt;<span class="symbol">&#x27;de</span>&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">peek_byte</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="string">b&#x27;i&#x27;</span>) =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">deserialize_i64</span>(visitor),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="string">b&#x27;l&#x27;</span>) =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">deserialize_seq</span>(visitor),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="string">b&#x27;d&#x27;</span>) =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">deserialize_map</span>(visitor),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="string">b&#x27;0&#x27;</span>..=<span class="string">b&#x27;9&#x27;</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">parse_bytes</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">parse_bytes</span>()?;</span><br><span class="line">            <span class="comment">//  这里需要注意，如果字符串无法转成utf8，则解析为二进制流</span></span><br><span class="line">            <span class="keyword">match</span> std::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(parse_bytes) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(s) =&gt; visitor.<span class="title function_ invoke__">visit_borrowed_str</span>(s),</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(_) =&gt; visitor.<span class="title function_ invoke__">visit_bytes</span>(parse_bytes),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; <span class="title function_ invoke__">Err</span>(Error::UnExpectedAny),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rubick-hqm.github.io/2025/03/02/serde/" data-id="cm9wq95t90000z8vjbkotgouf" data-title="serde的使用" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统_总结</a>
          </li>
        
          <li>
            <a href="/2025/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">操作系统_文件系统</a>
          </li>
        
          <li>
            <a href="/2025/04/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">操作系统_进程及进程管理</a>
          </li>
        
          <li>
            <a href="/2025/03/02/serde/">serde的使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>